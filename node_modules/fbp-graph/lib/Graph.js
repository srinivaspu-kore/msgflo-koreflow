//     FBP Graph
//     (c) 2013-2017 Flowhub UG
//     (c) 2011-2012 Henri Bergius, Nemein
//     FBP Graph may be freely distributed under the MIT license

// FBP graphs are Event Emitters, providing signals when the graph
// definition changes.

var EventEmitter, Graph, clone, mergeResolveTheirsNaive, platform, resetGraph;

({EventEmitter} = require('events'));

clone = require('clone');

platform = require('./Platform');

Graph = (function() {
  // This class represents an abstract FBP graph containing nodes
  // connected to each other with edges.

  // These graphs can be used for visualization and sketching, but
  // also are the way to start a NoFlo or other FBP network.
  class Graph extends EventEmitter {
    // ## Creating new graphs

    // Graphs are created by simply instantiating the Graph class
    // and giving it a name:

    //     myGraph = new Graph 'My very cool graph'
    constructor(name = '', options = {}) {
      super();
      this.setMaxListeners(0);
      this.name = name;
      this.properties = {};
      this.nodes = [];
      this.edges = [];
      this.initializers = [];
      this.inports = {};
      this.outports = {};
      this.groups = [];
      this.transaction = {
        id: null,
        depth: 0
      };
      this.caseSensitive = options.caseSensitive || false;
    }

    getPortName(port) {
      if (this.caseSensitive) {
        return port;
      } else {
        return port.toLowerCase();
      }
    }

    // ## Group graph changes into transactions

    // If no transaction is explicitly opened, each call to
    // the graph API will implicitly create a transaction for that change
    startTransaction(id, metadata) {
      if (this.transaction.id) {
        throw Error("Nested transactions not supported");
      }
      this.transaction.id = id;
      this.transaction.depth = 1;
      return this.emit('startTransaction', id, metadata);
    }

    endTransaction(id, metadata) {
      if (!this.transaction.id) {
        throw Error("Attempted to end non-existing transaction");
      }
      this.transaction.id = null;
      this.transaction.depth = 0;
      return this.emit('endTransaction', id, metadata);
    }

    checkTransactionStart() {
      if (!this.transaction.id) {
        return this.startTransaction('implicit');
      } else if (this.transaction.id === 'implicit') {
        return this.transaction.depth += 1;
      }
    }

    checkTransactionEnd() {
      if (this.transaction.id === 'implicit') {
        this.transaction.depth -= 1;
      }
      if (this.transaction.depth === 0) {
        return this.endTransaction('implicit');
      }
    }

    // ## Modifying Graph properties

    // This method allows changing properties of the graph.
    setProperties(properties) {
      var before, item, val;
      this.checkTransactionStart();
      before = clone(this.properties);
      for (item in properties) {
        val = properties[item];
        this.properties[item] = val;
      }
      this.emit('changeProperties', this.properties, before);
      return this.checkTransactionEnd();
    }

    addInport(publicPort, nodeKey, portKey, metadata) {
      // Check that node exists
      if (!this.getNode(nodeKey)) {
        return;
      }
      publicPort = this.getPortName(publicPort);
      this.checkTransactionStart();
      this.inports[publicPort] = {
        process: nodeKey,
        port: this.getPortName(portKey),
        metadata: metadata
      };
      this.emit('addInport', publicPort, this.inports[publicPort]);
      return this.checkTransactionEnd();
    }

    removeInport(publicPort) {
      var port;
      publicPort = this.getPortName(publicPort);
      if (!this.inports[publicPort]) {
        return;
      }
      this.checkTransactionStart();
      port = this.inports[publicPort];
      this.setInportMetadata(publicPort, {});
      delete this.inports[publicPort];
      this.emit('removeInport', publicPort, port);
      return this.checkTransactionEnd();
    }

    renameInport(oldPort, newPort) {
      oldPort = this.getPortName(oldPort);
      newPort = this.getPortName(newPort);
      if (!this.inports[oldPort]) {
        return;
      }
      if (newPort === oldPort) {
        return;
      }
      this.checkTransactionStart();
      this.inports[newPort] = this.inports[oldPort];
      delete this.inports[oldPort];
      this.emit('renameInport', oldPort, newPort);
      return this.checkTransactionEnd();
    }

    setInportMetadata(publicPort, metadata) {
      var before, item, val;
      publicPort = this.getPortName(publicPort);
      if (!this.inports[publicPort]) {
        return;
      }
      this.checkTransactionStart();
      before = clone(this.inports[publicPort].metadata);
      if (!this.inports[publicPort].metadata) {
        this.inports[publicPort].metadata = {};
      }
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          this.inports[publicPort].metadata[item] = val;
        } else {
          delete this.inports[publicPort].metadata[item];
        }
      }
      this.emit('changeInport', publicPort, this.inports[publicPort], before, metadata);
      return this.checkTransactionEnd();
    }

    addOutport(publicPort, nodeKey, portKey, metadata) {
      // Check that node exists
      if (!this.getNode(nodeKey)) {
        return;
      }
      publicPort = this.getPortName(publicPort);
      this.checkTransactionStart();
      this.outports[publicPort] = {
        process: nodeKey,
        port: this.getPortName(portKey),
        metadata: metadata
      };
      this.emit('addOutport', publicPort, this.outports[publicPort]);
      return this.checkTransactionEnd();
    }

    removeOutport(publicPort) {
      var port;
      publicPort = this.getPortName(publicPort);
      if (!this.outports[publicPort]) {
        return;
      }
      this.checkTransactionStart();
      port = this.outports[publicPort];
      this.setOutportMetadata(publicPort, {});
      delete this.outports[publicPort];
      this.emit('removeOutport', publicPort, port);
      return this.checkTransactionEnd();
    }

    renameOutport(oldPort, newPort) {
      oldPort = this.getPortName(oldPort);
      newPort = this.getPortName(newPort);
      if (!this.outports[oldPort]) {
        return;
      }
      this.checkTransactionStart();
      this.outports[newPort] = this.outports[oldPort];
      delete this.outports[oldPort];
      this.emit('renameOutport', oldPort, newPort);
      return this.checkTransactionEnd();
    }

    setOutportMetadata(publicPort, metadata) {
      var before, item, val;
      publicPort = this.getPortName(publicPort);
      if (!this.outports[publicPort]) {
        return;
      }
      this.checkTransactionStart();
      before = clone(this.outports[publicPort].metadata);
      if (!this.outports[publicPort].metadata) {
        this.outports[publicPort].metadata = {};
      }
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          this.outports[publicPort].metadata[item] = val;
        } else {
          delete this.outports[publicPort].metadata[item];
        }
      }
      this.emit('changeOutport', publicPort, this.outports[publicPort], before, metadata);
      return this.checkTransactionEnd();
    }

    // ## Grouping nodes in a graph

    addGroup(group, nodes, metadata) {
      var g;
      this.checkTransactionStart();
      g = {
        name: group,
        nodes: nodes,
        metadata: metadata
      };
      this.groups.push(g);
      this.emit('addGroup', g);
      return this.checkTransactionEnd();
    }

    renameGroup(oldName, newName) {
      var group, i, len, ref;
      this.checkTransactionStart();
      ref = this.groups;
      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        if (!group) {
          continue;
        }
        if (group.name !== oldName) {
          continue;
        }
        group.name = newName;
        this.emit('renameGroup', oldName, newName);
      }
      return this.checkTransactionEnd();
    }

    removeGroup(groupName) {
      var group, i, len, ref;
      this.checkTransactionStart();
      ref = this.groups;
      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        if (!group) {
          continue;
        }
        if (group.name !== groupName) {
          continue;
        }
        this.setGroupMetadata(group.name, {});
        this.groups.splice(this.groups.indexOf(group), 1);
        this.emit('removeGroup', group);
      }
      return this.checkTransactionEnd();
    }

    setGroupMetadata(groupName, metadata) {
      var before, group, i, item, len, ref, val;
      this.checkTransactionStart();
      ref = this.groups;
      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        if (!group) {
          continue;
        }
        if (group.name !== groupName) {
          continue;
        }
        before = clone(group.metadata);
        for (item in metadata) {
          val = metadata[item];
          if (val != null) {
            group.metadata[item] = val;
          } else {
            delete group.metadata[item];
          }
        }
        this.emit('changeGroup', group, before, metadata);
      }
      return this.checkTransactionEnd();
    }

    // ## Adding a node to the graph

    // Nodes are identified by an ID unique to the graph. Additionally,
    // a node may contain information on what FBP component it is and
    // possible display coordinates.

    // For example:

    //     myGraph.addNode 'Read, 'ReadFile',
    //       x: 91
    //       y: 154

    // Addition of a node will emit the `addNode` event.
    addNode(id, component, metadata) {
      var node;
      this.checkTransactionStart();
      if (!metadata) {
        metadata = {};
      }
      node = {
        id: id,
        component: component,
        metadata: metadata
      };
      this.nodes.push(node);
      this.emit('addNode', node);
      this.checkTransactionEnd();
      return node;
    }

    // ## Removing a node from the graph

    // Existing nodes can be removed from a graph by their ID. This
    // will remove the node and also remove all edges connected to it.

    //     myGraph.removeNode 'Read'

    // Once the node has been removed, the `removeNode` event will be
    // emitted.
    removeNode(id) {
      var edge, group, i, index, initializer, j, k, l, len, len1, len2, len3, len4, len5, len6, m, n, node, o, priv, pub, ref, ref1, ref2, ref3, ref4, toRemove;
      node = this.getNode(id);
      if (!node) {
        return;
      }
      this.checkTransactionStart();
      toRemove = [];
      ref = this.edges;
      for (i = 0, len = ref.length; i < len; i++) {
        edge = ref[i];
        if ((edge.from.node === node.id) || (edge.to.node === node.id)) {
          toRemove.push(edge);
        }
      }
      for (j = 0, len1 = toRemove.length; j < len1; j++) {
        edge = toRemove[j];
        this.removeEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port);
      }
      toRemove = [];
      ref1 = this.initializers;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        initializer = ref1[k];
        if (initializer.to.node === node.id) {
          toRemove.push(initializer);
        }
      }
      for (l = 0, len3 = toRemove.length; l < len3; l++) {
        initializer = toRemove[l];
        this.removeInitial(initializer.to.node, initializer.to.port);
      }
      toRemove = [];
      ref2 = this.inports;
      for (pub in ref2) {
        priv = ref2[pub];
        if (priv.process === id) {
          toRemove.push(pub);
        }
      }
      for (m = 0, len4 = toRemove.length; m < len4; m++) {
        pub = toRemove[m];
        this.removeInport(pub);
      }
      toRemove = [];
      ref3 = this.outports;
      for (pub in ref3) {
        priv = ref3[pub];
        if (priv.process === id) {
          toRemove.push(pub);
        }
      }
      for (n = 0, len5 = toRemove.length; n < len5; n++) {
        pub = toRemove[n];
        this.removeOutport(pub);
      }
      ref4 = this.groups;
      for (o = 0, len6 = ref4.length; o < len6; o++) {
        group = ref4[o];
        if (!group) {
          continue;
        }
        index = group.nodes.indexOf(id);
        if (index === -1) {
          continue;
        }
        group.nodes.splice(index, 1);
      }
      this.setNodeMetadata(id, {});
      if (-1 !== this.nodes.indexOf(node)) {
        this.nodes.splice(this.nodes.indexOf(node), 1);
      }
      this.emit('removeNode', node);
      return this.checkTransactionEnd();
    }

    // ## Getting a node

    // Nodes objects can be retrieved from the graph by their ID:

    //     myNode = myGraph.getNode 'Read'
    getNode(id) {
      var i, len, node, ref;
      ref = this.nodes;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        if (!node) {
          continue;
        }
        if (node.id === id) {
          return node;
        }
      }
      return null;
    }

    // ## Renaming a node

    // Nodes IDs can be changed by calling this method.
    renameNode(oldId, newId) {
      var edge, group, i, iip, index, j, k, len, len1, len2, node, priv, pub, ref, ref1, ref2, ref3, ref4;
      this.checkTransactionStart();
      node = this.getNode(oldId);
      if (!node) {
        return;
      }
      node.id = newId;
      ref = this.edges;
      for (i = 0, len = ref.length; i < len; i++) {
        edge = ref[i];
        if (!edge) {
          continue;
        }
        if (edge.from.node === oldId) {
          edge.from.node = newId;
        }
        if (edge.to.node === oldId) {
          edge.to.node = newId;
        }
      }
      ref1 = this.initializers;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        iip = ref1[j];
        if (!iip) {
          continue;
        }
        if (iip.to.node === oldId) {
          iip.to.node = newId;
        }
      }
      ref2 = this.inports;
      for (pub in ref2) {
        priv = ref2[pub];
        if (priv.process === oldId) {
          priv.process = newId;
        }
      }
      ref3 = this.outports;
      for (pub in ref3) {
        priv = ref3[pub];
        if (priv.process === oldId) {
          priv.process = newId;
        }
      }
      ref4 = this.groups;
      for (k = 0, len2 = ref4.length; k < len2; k++) {
        group = ref4[k];
        if (!group) {
          continue;
        }
        index = group.nodes.indexOf(oldId);
        if (index === -1) {
          continue;
        }
        group.nodes[index] = newId;
      }
      this.emit('renameNode', oldId, newId);
      return this.checkTransactionEnd();
    }

    // ## Changing a node's metadata

    // Node metadata can be set or changed by calling this method.
    setNodeMetadata(id, metadata) {
      var before, item, node, val;
      node = this.getNode(id);
      if (!node) {
        return;
      }
      this.checkTransactionStart();
      before = clone(node.metadata);
      if (!node.metadata) {
        node.metadata = {};
      }
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          node.metadata[item] = val;
        } else {
          delete node.metadata[item];
        }
      }
      this.emit('changeNode', node, before, metadata);
      return this.checkTransactionEnd();
    }

    // ## Connecting nodes

    // Nodes can be connected by adding edges between a node's outport
    // and another node's inport:

    //     myGraph.addEdge 'Read', 'out', 'Display', 'in'
    //     myGraph.addEdgeIndex 'Read', 'out', null, 'Display', 'in', 2

    // Adding an edge will emit the `addEdge` event.
    addEdge(outNode, outPort, inNode, inPort, metadata = {}) {
      var edge, i, len, ref;
      outPort = this.getPortName(outPort);
      inPort = this.getPortName(inPort);
      ref = this.edges;
      for (i = 0, len = ref.length; i < len; i++) {
        edge = ref[i];
        // don't add a duplicate edge
        if (edge.from.node === outNode && edge.from.port === outPort && edge.to.node === inNode && edge.to.port === inPort) {
          return;
        }
      }
      if (!this.getNode(outNode)) {
        return;
      }
      if (!this.getNode(inNode)) {
        return;
      }
      this.checkTransactionStart();
      edge = {
        from: {
          node: outNode,
          port: outPort
        },
        to: {
          node: inNode,
          port: inPort
        },
        metadata: metadata
      };
      this.edges.push(edge);
      this.emit('addEdge', edge);
      this.checkTransactionEnd();
      return edge;
    }

    // Adding an edge will emit the `addEdge` event.
    addEdgeIndex(outNode, outPort, outIndex, inNode, inPort, inIndex, metadata = {}) {
      var edge;
      if (!this.getNode(outNode)) {
        return;
      }
      if (!this.getNode(inNode)) {
        return;
      }
      outPort = this.getPortName(outPort);
      inPort = this.getPortName(inPort);
      if (inIndex === null) {
        inIndex = void 0;
      }
      if (outIndex === null) {
        outIndex = void 0;
      }
      if (!metadata) {
        metadata = {};
      }
      this.checkTransactionStart();
      edge = {
        from: {
          node: outNode,
          port: outPort,
          index: outIndex
        },
        to: {
          node: inNode,
          port: inPort,
          index: inIndex
        },
        metadata: metadata
      };
      this.edges.push(edge);
      this.emit('addEdge', edge);
      this.checkTransactionEnd();
      return edge;
    }

    // ## Disconnected nodes

    // Connections between nodes can be removed by providing the
    // nodes and ports to disconnect.

    //     myGraph.removeEdge 'Display', 'out', 'Foo', 'in'

    // Removing a connection will emit the `removeEdge` event.
    removeEdge(node, port, node2, port2) {
      var edge, i, index, j, k, len, len1, len2, ref, ref1, toKeep, toRemove;
      this.checkTransactionStart();
      port = this.getPortName(port);
      port2 = this.getPortName(port2);
      toRemove = [];
      toKeep = [];
      if (node2 && port2) {
        ref = this.edges;
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          edge = ref[index];
          if (edge.from.node === node && edge.from.port === port && edge.to.node === node2 && edge.to.port === port2) {
            this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
            toRemove.push(edge);
          } else {
            toKeep.push(edge);
          }
        }
      } else {
        ref1 = this.edges;
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          edge = ref1[index];
          if ((edge.from.node === node && edge.from.port === port) || (edge.to.node === node && edge.to.port === port)) {
            this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
            toRemove.push(edge);
          } else {
            toKeep.push(edge);
          }
        }
      }
      this.edges = toKeep;
      for (k = 0, len2 = toRemove.length; k < len2; k++) {
        edge = toRemove[k];
        this.emit('removeEdge', edge);
      }
      return this.checkTransactionEnd();
    }

    // ## Getting an edge

    // Edge objects can be retrieved from the graph by the node and port IDs:

    //     myEdge = myGraph.getEdge 'Read', 'out', 'Write', 'in'
    getEdge(node, port, node2, port2) {
      var edge, i, index, len, ref;
      port = this.getPortName(port);
      port2 = this.getPortName(port2);
      ref = this.edges;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        edge = ref[index];
        if (!edge) {
          continue;
        }
        if (edge.from.node === node && edge.from.port === port) {
          if (edge.to.node === node2 && edge.to.port === port2) {
            return edge;
          }
        }
      }
      return null;
    }

    // ## Changing an edge's metadata

    // Edge metadata can be set or changed by calling this method.
    setEdgeMetadata(node, port, node2, port2, metadata) {
      var before, edge, item, val;
      edge = this.getEdge(node, port, node2, port2);
      if (!edge) {
        return;
      }
      this.checkTransactionStart();
      before = clone(edge.metadata);
      if (!edge.metadata) {
        edge.metadata = {};
      }
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          edge.metadata[item] = val;
        } else {
          delete edge.metadata[item];
        }
      }
      this.emit('changeEdge', edge, before, metadata);
      return this.checkTransactionEnd();
    }

    // ## Adding Initial Information Packets

    // Initial Information Packets (IIPs) can be used for sending data
    // to specified node inports without a sending node instance.

    // IIPs are especially useful for sending configuration information
    // to components at FBP network start-up time. This could include
    // filenames to read, or network ports to listen to.

    //     myGraph.addInitial 'somefile.txt', 'Read', 'source'
    //     myGraph.addInitialIndex 'somefile.txt', 'Read', 'source', 2

    // If inports are defined on the graph, IIPs can be applied calling
    // the `addGraphInitial` or `addGraphInitialIndex` methods.

    //     myGraph.addGraphInitial 'somefile.txt', 'file'
    //     myGraph.addGraphInitialIndex 'somefile.txt', 'file', 2

    // Adding an IIP will emit a `addInitial` event.
    addInitial(data, node, port, metadata) {
      var initializer;
      if (!this.getNode(node)) {
        return;
      }
      port = this.getPortName(port);
      this.checkTransactionStart();
      initializer = {
        from: {
          data: data
        },
        to: {
          node: node,
          port: port
        },
        metadata: metadata
      };
      this.initializers.push(initializer);
      this.emit('addInitial', initializer);
      this.checkTransactionEnd();
      return initializer;
    }

    addInitialIndex(data, node, port, index, metadata) {
      var initializer;
      if (!this.getNode(node)) {
        return;
      }
      if (index === null) {
        index = void 0;
      }
      port = this.getPortName(port);
      this.checkTransactionStart();
      initializer = {
        from: {
          data: data
        },
        to: {
          node: node,
          port: port,
          index: index
        },
        metadata: metadata
      };
      this.initializers.push(initializer);
      this.emit('addInitial', initializer);
      this.checkTransactionEnd();
      return initializer;
    }

    addGraphInitial(data, node, metadata) {
      var inport;
      inport = this.inports[node];
      if (!inport) {
        return;
      }
      return this.addInitial(data, inport.process, inport.port, metadata);
    }

    addGraphInitialIndex(data, node, index, metadata) {
      var inport;
      inport = this.inports[node];
      if (!inport) {
        return;
      }
      return this.addInitialIndex(data, inport.process, inport.port, index, metadata);
    }

    // ## Removing Initial Information Packets

    // IIPs can be removed by calling the `removeInitial` method.

    //     myGraph.removeInitial 'Read', 'source'

    // If the IIP was applied via the `addGraphInitial` or
    // `addGraphInitialIndex` functions, it can be removed using
    // the `removeGraphInitial` method.

    //     myGraph.removeGraphInitial 'file'

    // Remove an IIP will emit a `removeInitial` event.
    removeInitial(node, port) {
      var edge, i, index, j, len, len1, ref, toKeep, toRemove;
      port = this.getPortName(port);
      this.checkTransactionStart();
      toRemove = [];
      toKeep = [];
      ref = this.initializers;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        edge = ref[index];
        if (edge.to.node === node && edge.to.port === port) {
          toRemove.push(edge);
        } else {
          toKeep.push(edge);
        }
      }
      this.initializers = toKeep;
      for (j = 0, len1 = toRemove.length; j < len1; j++) {
        edge = toRemove[j];
        this.emit('removeInitial', edge);
      }
      return this.checkTransactionEnd();
    }

    removeGraphInitial(node) {
      var inport;
      inport = this.inports[node];
      if (!inport) {
        return;
      }
      return this.removeInitial(inport.process, inport.port);
    }

    toDOT() {
      var cleanID, cleanPort, data, dot, edge, i, id, initializer, j, k, len, len1, len2, node, ref, ref1, ref2;
      cleanID = function(id) {
        return id.replace(/\s*/g, "");
      };
      cleanPort = function(port) {
        return port.replace(/\./g, "");
      };
      dot = "digraph {\n";
      ref = this.nodes;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        dot += `    ${cleanID(node.id)} [label=${node.id} shape=box]\n`;
      }
      ref1 = this.initializers;
      for (id = j = 0, len1 = ref1.length; j < len1; id = ++j) {
        initializer = ref1[id];
        if (typeof initializer.from.data === 'function') {
          data = 'Function';
        } else {
          data = initializer.from.data;
        }
        dot += `    data${id} [label="'${data}'" shape=plaintext]\n`;
        dot += `    data${id} -> ${cleanID(initializer.to.node)}[headlabel=${cleanPort(initializer.to.port)} labelfontcolor=blue labelfontsize=8.0]\n`;
      }
      ref2 = this.edges;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        edge = ref2[k];
        dot += `    ${cleanID(edge.from.node)} -> ${cleanID(edge.to.node)}[taillabel=${cleanPort(edge.from.port)} headlabel=${cleanPort(edge.to.port)} labelfontcolor=blue labelfontsize=8.0]\n`;
      }
      dot += "}";
      return dot;
    }

    toYUML() {
      var edge, i, initializer, j, len, len1, ref, ref1, yuml;
      yuml = [];
      ref = this.initializers;
      for (i = 0, len = ref.length; i < len; i++) {
        initializer = ref[i];
        yuml.push(`(start)[${initializer.to.port}]->(${initializer.to.node})`);
      }
      ref1 = this.edges;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        yuml.push(`(${edge.from.node})[${edge.from.port}]->(${edge.to.node})`);
      }
      return yuml.join(",");
    }

    toJSON() {
      var connection, edge, group, groupData, i, initializer, j, json, k, l, len, len1, len2, len3, node, priv, property, pub, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      json = {
        caseSensitive: this.caseSensitive,
        properties: {},
        inports: {},
        outports: {},
        groups: [],
        processes: {},
        connections: []
      };
      if (this.name) {
        json.properties.name = this.name;
      }
      ref = this.properties;
      for (property in ref) {
        value = ref[property];
        json.properties[property] = value;
      }
      ref1 = this.inports;
      for (pub in ref1) {
        priv = ref1[pub];
        json.inports[pub] = priv;
      }
      ref2 = this.outports;
      for (pub in ref2) {
        priv = ref2[pub];
        json.outports[pub] = priv;
      }
      ref3 = this.groups;
      for (i = 0, len = ref3.length; i < len; i++) {
        group = ref3[i];
        groupData = {
          name: group.name,
          nodes: group.nodes
        };
        if (Object.keys(group.metadata).length) {
          groupData.metadata = group.metadata;
        }
        json.groups.push(groupData);
      }
      ref4 = this.nodes;
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        node = ref4[j];
        json.processes[node.id] = {
          component: node.component
        };
        if (node.metadata) {
          json.processes[node.id].metadata = node.metadata;
        }
      }
      ref5 = this.edges;
      for (k = 0, len2 = ref5.length; k < len2; k++) {
        edge = ref5[k];
        connection = {
          src: {
            process: edge.from.node,
            port: edge.from.port,
            index: edge.from.index
          },
          tgt: {
            process: edge.to.node,
            port: edge.to.port,
            index: edge.to.index
          }
        };
        if (Object.keys(edge.metadata).length) {
          connection.metadata = edge.metadata;
        }
        json.connections.push(connection);
      }
      ref6 = this.initializers;
      for (l = 0, len3 = ref6.length; l < len3; l++) {
        initializer = ref6[l];
        json.connections.push({
          data: initializer.from.data,
          tgt: {
            process: initializer.to.node,
            port: initializer.to.port,
            index: initializer.to.index
          }
        });
      }
      return json;
    }

    save(file, callback) {
      var json;
      if (platform.isBrowser()) {
        return callback(new Error("Saving graphs not supported on browser"));
      }
      json = JSON.stringify(this.toJSON(), null, 4);
      if (!file.match(/\.json$/)) {
        file = `${file}.json`;
      }
      return require('fs').writeFile(file, json, "utf-8", function(err, data) {
        if (err) {
          return callback(err);
        }
        return callback(null, file);
      });
    }

  };

  Graph.prototype.name = '';

  Graph.prototype.caseSensitive = false;

  Graph.prototype.properties = {};

  Graph.prototype.nodes = [];

  Graph.prototype.edges = [];

  Graph.prototype.initializers = [];

  Graph.prototype.inports = {};

  Graph.prototype.outports = {};

  Graph.prototype.groups = [];

  return Graph;

}).call(this);

exports.Graph = Graph;

exports.createGraph = function(name, options) {
  return new Graph(name, options);
};

exports.loadJSON = function(definition, callback, metadata = {}) {
  var caseSensitive, conn, def, graph, group, i, id, j, len, len1, priv, properties, property, pub, ref, ref1, ref2, ref3, ref4, ref5, value;
  if (typeof definition === 'string') {
    definition = JSON.parse(definition);
  }
  if (!definition.properties) {
    definition.properties = {};
  }
  if (!definition.processes) {
    definition.processes = {};
  }
  if (!definition.connections) {
    definition.connections = [];
  }
  caseSensitive = definition.caseSensitive || false;
  graph = new Graph(definition.properties.name, {caseSensitive});
  graph.startTransaction('loadJSON', metadata);
  properties = {};
  ref = definition.properties;
  for (property in ref) {
    value = ref[property];
    if (property === 'name') {
      continue;
    }
    properties[property] = value;
  }
  graph.setProperties(properties);
  ref1 = definition.processes;
  for (id in ref1) {
    def = ref1[id];
    if (!def.metadata) {
      def.metadata = {};
    }
    graph.addNode(id, def.component, def.metadata);
  }
  ref2 = definition.connections;
  for (i = 0, len = ref2.length; i < len; i++) {
    conn = ref2[i];
    metadata = conn.metadata ? conn.metadata : {};
    if (conn.data !== void 0) {
      if (typeof conn.tgt.index === 'number') {
        graph.addInitialIndex(conn.data, conn.tgt.process, graph.getPortName(conn.tgt.port), conn.tgt.index, metadata);
      } else {
        graph.addInitial(conn.data, conn.tgt.process, graph.getPortName(conn.tgt.port), metadata);
      }
      continue;
    }
    if (typeof conn.src.index === 'number' || typeof conn.tgt.index === 'number') {
      graph.addEdgeIndex(conn.src.process, graph.getPortName(conn.src.port), conn.src.index, conn.tgt.process, graph.getPortName(conn.tgt.port), conn.tgt.index, metadata);
      continue;
    }
    graph.addEdge(conn.src.process, graph.getPortName(conn.src.port), conn.tgt.process, graph.getPortName(conn.tgt.port), metadata);
  }
  if (definition.inports) {
    ref3 = definition.inports;
    for (pub in ref3) {
      priv = ref3[pub];
      graph.addInport(pub, priv.process, graph.getPortName(priv.port), priv.metadata);
    }
  }
  if (definition.outports) {
    ref4 = definition.outports;
    for (pub in ref4) {
      priv = ref4[pub];
      graph.addOutport(pub, priv.process, graph.getPortName(priv.port), priv.metadata);
    }
  }
  if (definition.groups) {
    ref5 = definition.groups;
    for (j = 0, len1 = ref5.length; j < len1; j++) {
      group = ref5[j];
      graph.addGroup(group.name, group.nodes, group.metadata || {});
    }
  }
  graph.endTransaction('loadJSON');
  return callback(null, graph);
};

exports.loadFBP = function(fbpData, callback, metadata = {}, caseSensitive = false) {
  var definition, e;
  try {
    definition = require('fbp').parse(fbpData, {caseSensitive});
  } catch (error) {
    e = error;
    return callback(e);
  }
  return exports.loadJSON(definition, callback, metadata);
};

exports.loadHTTP = function(url, callback) {
  var req;
  req = new XMLHttpRequest;
  req.onreadystatechange = function() {
    if (req.readyState !== 4) {
      return;
    }
    if (req.status !== 200) {
      return callback(new Error(`Failed to load ${url}: HTTP ${req.status}`));
    }
    return callback(null, req.responseText);
  };
  req.open('GET', url, true);
  return req.send();
};

exports.loadFile = function(file, callback, metadata = {}, caseSensitive = false) {
  if (platform.isBrowser()) {
    // On browser we can try getting the file via AJAX
    exports.loadHTTP(file, function(err, data) {
      var definition;
      if (err) {
        return callback(err);
      }
      if (file.split('.').pop() === 'fbp') {
        return exports.loadFBP(data, callback, metadata);
      }
      definition = JSON.parse(data);
      return exports.loadJSON(definition, callback, metadata);
    });
    return;
  }
  // Node.js graph file
  return require('fs').readFile(file, "utf-8", function(err, data) {
    var definition;
    if (err) {
      return callback(err);
    }
    if (file.split('.').pop() === 'fbp') {
      return exports.loadFBP(data, callback, {}, caseSensitive);
    }
    definition = JSON.parse(data);
    return exports.loadJSON(definition, callback, {});
  });
};

// remove everything in the graph
resetGraph = function(graph) {
  var edge, group, i, iip, j, k, l, len, len1, len2, len3, node, port, ref, ref1, ref2, ref3, ref4, ref5, results, v;
  ref = (clone(graph.groups)).reverse();
  // Edges and similar first, to have control over the order
  // If we'd do nodes first, it will implicitly delete edges
  // Important to make journal transactions invertible
  for (i = 0, len = ref.length; i < len; i++) {
    group = ref[i];
    if (group != null) {
      graph.removeGroup(group.name);
    }
  }
  ref1 = clone(graph.outports);
  for (port in ref1) {
    v = ref1[port];
    graph.removeOutport(port);
  }
  ref2 = clone(graph.inports);
  for (port in ref2) {
    v = ref2[port];
    graph.removeInport(port);
  }
  // XXX: does this actually null the props??
  graph.setProperties({});
  ref3 = (clone(graph.initializers)).reverse();
  for (j = 0, len1 = ref3.length; j < len1; j++) {
    iip = ref3[j];
    graph.removeInitial(iip.to.node, iip.to.port);
  }
  ref4 = (clone(graph.edges)).reverse();
  for (k = 0, len2 = ref4.length; k < len2; k++) {
    edge = ref4[k];
    graph.removeEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port);
  }
  ref5 = (clone(graph.nodes)).reverse();
  results = [];
  for (l = 0, len3 = ref5.length; l < len3; l++) {
    node = ref5[l];
    results.push(graph.removeNode(node.id));
  }
  return results;
};

// Note: Caller should create transaction
// First removes everything in @base, before building it up to mirror @to
mergeResolveTheirsNaive = function(base, to) {
  var edge, group, i, iip, j, k, l, len, len1, len2, len3, node, priv, pub, ref, ref1, ref2, ref3, ref4, ref5, results;
  resetGraph(base);
  ref = to.nodes;
  for (i = 0, len = ref.length; i < len; i++) {
    node = ref[i];
    base.addNode(node.id, node.component, node.metadata);
  }
  ref1 = to.edges;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    edge = ref1[j];
    base.addEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port, edge.metadata);
  }
  ref2 = to.initializers;
  for (k = 0, len2 = ref2.length; k < len2; k++) {
    iip = ref2[k];
    base.addInitial(iip.from.data, iip.to.node, iip.to.port, iip.metadata);
  }
  base.setProperties(to.properties);
  ref3 = to.inports;
  for (pub in ref3) {
    priv = ref3[pub];
    base.addInport(pub, priv.process, priv.port, priv.metadata);
  }
  ref4 = to.outports;
  for (pub in ref4) {
    priv = ref4[pub];
    base.addOutport(pub, priv.process, priv.port, priv.metadata);
  }
  ref5 = to.groups;
  results = [];
  for (l = 0, len3 = ref5.length; l < len3; l++) {
    group = ref5[l];
    results.push(base.addGroup(group.name, group.nodes, group.metadata));
  }
  return results;
};

exports.equivalent = function(a, b, options = {}) {
  var A, B;
  // TODO: add option to only compare known fields
  // TODO: add option to ignore metadata
  A = JSON.stringify(a);
  B = JSON.stringify(b);
  return A === B;
};

exports.mergeResolveTheirs = mergeResolveTheirsNaive;
