//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2014-2017 Flowhub UG
//     NoFlo may be freely distributed under the MIT license
var BasePort, IP, OutPort;

BasePort = require('./BasePort');

IP = require('./IP');

// ## NoFlo outport

// Outport Port (outport) implementation for NoFlo components.
// These ports are the way a component sends Information Packets.
OutPort = class OutPort extends BasePort {
  constructor(options = {}) {
    if (options.scoped == null) {
      options.scoped = true;
    }
    super(options);
    this.cache = {};
  }

  attach(socket, index = null) {
    super.attach(socket, index);
    if (this.isCaching() && (this.cache[index] != null)) {
      return this.send(this.cache[index], index);
    }
  }

  connect(socketId = null) {
    var i, len, results, socket, sockets;
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.connect());
    }
    return results;
  }

  beginGroup(group, socketId = null) {
    var sockets;
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (!socket) {
        return;
      }
      return socket.beginGroup(group);
    });
  }

  send(data, socketId = null) {
    var sockets;
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    if (this.isCaching() && data !== this.cache[socketId]) {
      this.cache[socketId] = data;
    }
    return sockets.forEach(function(socket) {
      if (!socket) {
        return;
      }
      return socket.send(data);
    });
  }

  endGroup(socketId = null) {
    var i, len, results, socket, sockets;
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.endGroup());
    }
    return results;
  }

  disconnect(socketId = null) {
    var i, len, results, socket, sockets;
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.disconnect());
    }
    return results;
  }

  sendIP(type, data, options, socketId, autoConnect = true) {
    var i, ip, len, pristine, ref, socket, sockets;
    if (IP.isIP(type)) {
      ip = type;
      socketId = ip.index;
    } else {
      ip = new IP(type, data, options);
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    if (ip.datatype === 'all') {
      // Stamp non-specific IP objects with port datatype
      ip.datatype = this.getDataType();
    }
    if (this.getSchema() && !ip.schema) {
      // Stamp non-specific IP objects with port schema
      ip.schema = this.getSchema();
    }
    if (this.isCaching() && data !== ((ref = this.cache[socketId]) != null ? ref.data : void 0)) {
      this.cache[socketId] = ip;
    }
    pristine = true;
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      if (pristine) {
        socket.post(ip, autoConnect);
        pristine = false;
      } else {
        if (ip.clonable) {
          ip = ip.clone();
        }
        socket.post(ip, autoConnect);
      }
    }
    return this;
  }

  openBracket(data = null, options = {}, socketId = null) {
    return this.sendIP('openBracket', data, options, socketId);
  }

  data(data, options = {}, socketId = null) {
    return this.sendIP('data', data, options, socketId);
  }

  closeBracket(data = null, options = {}, socketId = null) {
    return this.sendIP('closeBracket', data, options, socketId);
  }

  checkRequired(sockets) {
    if (sockets.length === 0 && this.isRequired()) {
      throw new Error(`${this.getId()}: No connections available`);
    }
  }

  getSockets(socketId) {
    // Addressable sockets affect only one connection at time
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error(`${this.getId()} Socket ID required`);
      }
      if (!this.sockets[socketId]) {
        return [];
      }
      return [this.sockets[socketId]];
    }
    // Regular sockets affect all outbound connections
    return this.sockets;
  }

  isCaching() {
    if (this.options.caching) {
      return true;
    }
    return false;
  }

};

module.exports = OutPort;
