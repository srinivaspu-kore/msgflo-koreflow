//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2014-2017 Flowhub UG
//     NoFlo may be freely distributed under the MIT license
var EventEmitter, InPort, InPorts, OutPort, OutPorts, Ports;

({EventEmitter} = require('events'));

InPort = require('./InPort');

OutPort = require('./OutPort');

Ports = (function() {
  // NoFlo ports collections

  // Ports collection classes for NoFlo components. These are
  // used to hold a set of input or output ports of a component.
  class Ports extends EventEmitter {
    constructor(ports) {
      var name, options;
      super();
      this.ports = {};
      if (!ports) {
        return;
      }
      for (name in ports) {
        options = ports[name];
        this.add(name, options);
      }
    }

    add(name, options, process) {
      if (name === 'add' || name === 'remove') {
        throw new Error('Add and remove are restricted port names');
      }
      if (!name.match(/^[a-z0-9_\.\/]+$/)) {
        throw new Error(`Port names can only contain lowercase alphanumeric characters and underscores. '${name}' not allowed`);
      }
      if (this.ports[name]) {
        // Remove previous implementation
        this.remove(name);
      }
      if (typeof options === 'object' && options.canAttach) {
        this.ports[name] = options;
      } else {
        this.ports[name] = new this.model(options, process);
      }
      this[name] = this.ports[name];
      this.emit('add', name);
      return this;
    }

    remove(name) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not defined`);
      }
      delete this.ports[name];
      delete this[name];
      this.emit('remove', name);
      return this;
    }

  };

  Ports.prototype.model = InPort;

  return Ports;

}).call(this);

exports.InPorts = InPorts = class InPorts extends Ports {
  on(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error(`Port ${name} not available`);
    }
    return this.ports[name].on(event, callback);
  }

  once(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error(`Port ${name} not available`);
    }
    return this.ports[name].once(event, callback);
  }

};

exports.OutPorts = OutPorts = (function() {
  class OutPorts extends Ports {
    connect(name, socketId) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not available`);
      }
      return this.ports[name].connect(socketId);
    }

    beginGroup(name, group, socketId) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not available`);
      }
      return this.ports[name].beginGroup(group, socketId);
    }

    send(name, data, socketId) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not available`);
      }
      return this.ports[name].send(data, socketId);
    }

    endGroup(name, socketId) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not available`);
      }
      return this.ports[name].endGroup(socketId);
    }

    disconnect(name, socketId) {
      if (!this.ports[name]) {
        throw new Error(`Port ${name} not available`);
      }
      return this.ports[name].disconnect(socketId);
    }

  };

  OutPorts.prototype.model = OutPort;

  return OutPorts;

}).call(this);

// Port name normalization:
// returns object containing keys name and index for ports names in
// format `portname` or `portname[index]`.
exports.normalizePortName = function(name) {
  var matched, port;
  port = {
    name: name
  };
  if (name.indexOf('[') === -1) {
    // Regular port
    return port;
  }
  // Addressable port with index
  matched = name.match(/(.*)\[([0-9]+)\]/);
  if (!(matched != null ? matched.length : void 0)) {
    return name;
  }
  port.name = matched[1];
  port.index = matched[2];
  return port;
};
