//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2017-2018 Flowhub UG
//     NoFlo may be freely distributed under the MIT license
var ComponentLoader, Graph, IP, Network, getType, internalSocket, normalizeOptions, normalizeOutput, prepareInputMap, prepareNetwork, runNetwork, sendOutputMap;

ComponentLoader = require('./ComponentLoader').ComponentLoader;

Network = require('./Network').Network;

IP = require('./IP');

internalSocket = require('./InternalSocket');

Graph = require('fbp-graph').Graph;

// ## asCallback embedding API

// asCallback is a helper for embedding NoFlo components or
// graphs in other JavaScript programs.

// By using the `noflo.asCallback` function, you can turn any
// NoFlo component or NoFlo Graph instance into a regular,
// Node.js-style JavaScript function.

// Each call to that function starts a new NoFlo network where
// the given input arguments are sent as IP objects to matching
// inports. Once the network finishes, the IP objects received
// from the network will be sent to the callback function.

// If there was anything sent to an `error` outport, this will
// be provided as the error argument to the callback.

// ### Option normalization

// Here we handle the input valus given to the `asCallback`
// function. This allows passing things like a pre-initialized
// NoFlo ComponentLoader, or giving the component loading
// baseDir context.
normalizeOptions = function(options, component) {
  if (!options) {
    options = {};
  }
  if (!options.name) {
    options.name = component;
  }
  if (options.loader) {
    options.baseDir = options.loader.baseDir;
  }
  if (!options.baseDir && process && process.cwd) {
    options.baseDir = process.cwd();
  }
  if (!options.loader) {
    options.loader = new ComponentLoader(options.baseDir);
  }
  if (!options.raw) {
    options.raw = false;
  }
  return options;
};

// ### Network preparation

// Each invocation of the asCallback-wrapped NoFlo graph
// creates a new network. This way we can isolate multiple
// executions of the function in their own contexts.
prepareNetwork = function(component, options, callback) {
  var network;
  // If we were given a graph instance, then just create a network
  if (typeof component === 'object') {
    component.componentLoader = options.loader;
    network = new Network(component, options);
    // Wire the network up
    network.connect(function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, network);
    });
    return;
  }
  // Start by loading the component
  return options.loader.load(component, function(err, instance) {
    var def, graph, inPorts, nodeName, outPorts, port;
    if (err) {
      return callback(err);
    }
    // Prepare a graph wrapping the component
    graph = new Graph(options.name);
    nodeName = options.name;
    graph.addNode(nodeName, component);
    // Expose ports
    inPorts = instance.inPorts.ports;
    outPorts = instance.outPorts.ports;
    for (port in inPorts) {
      def = inPorts[port];
      graph.addInport(port, nodeName, port);
    }
    for (port in outPorts) {
      def = outPorts[port];
      graph.addOutport(port, nodeName, port);
    }
    // Prepare network
    graph.componentLoader = options.loader;
    network = new Network(graph, options);
    // Wire the network up and start execution
    return network.connect(function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, network);
    });
  });
};

// ### Network execution

// Once network is ready, we connect to all of its exported
// in and outports and start the network.

// Input data is sent to the inports, and we collect IP
// packets received on the outports.

// Once the network finishes, we send the resulting IP
// objects to the callback.
runNetwork = function(network, inputs, options, callback) {
  var inPorts, inSockets, outPorts, outSockets, received;
  // Prepare inports
  inPorts = Object.keys(network.graph.inports);
  inSockets = {};
  // Subscribe outports
  received = [];
  outPorts = Object.keys(network.graph.outports);
  outSockets = {};
  outPorts.forEach(function(outport) {
    var portDef, process;
    portDef = network.graph.outports[outport];
    process = network.getNode(portDef.process);
    outSockets[outport] = internalSocket.createSocket();
    process.component.outPorts[portDef.port].attach(outSockets[outport]);
    outSockets[outport].from = {
      process: process,
      port: portDef.port
    };
    return outSockets[outport].on('ip', function(ip) {
      var res;
      res = {};
      res[outport] = ip;
      return received.push(res);
    });
  });
  // Subscribe network finish
  network.once('end', function() {
    var port, socket;
// Clear listeners
    for (port in outSockets) {
      socket = outSockets[port];
      socket.from.process.component.outPorts[socket.from.port].detach(socket);
    }
    outSockets = {};
    inSockets = {};
    return callback(null, received);
  });
  // Start network
  return network.start(function(err) {
    var i, inputMap, len, port, portDef, process, results, value;
    if (err) {
      return callback(err);
    }
// Send inputs
    results = [];
    for (i = 0, len = inputs.length; i < len; i++) {
      inputMap = inputs[i];
      results.push((function() {
        var results1;
        results1 = [];
        for (port in inputMap) {
          value = inputMap[port];
          if (!inSockets[port]) {
            portDef = network.graph.inports[port];
            process = network.getNode(portDef.process);
            inSockets[port] = internalSocket.createSocket();
            process.component.inPorts[portDef.port].attach(inSockets[port]);
          }
          if (IP.isIP(value)) {
            inSockets[port].post(value);
            continue;
          }
          results1.push(inSockets[port].post(new IP('data', value)));
        }
        return results1;
      })());
    }
    return results;
  });
};

getType = function(inputs, network) {
  var key, maps, value;
  if (typeof inputs !== 'object') {
    // Scalar values are always simple inputs
    return 'simple';
  }
  if (Array.isArray(inputs)) {
    maps = inputs.filter(function(entry) {
      return getType(entry, network) === 'map';
    });
    if (maps.length === inputs.length) {
      // If each member if the array is an input map, this is a sequence
      return 'sequence';
    }
    // Otherwise arrays must be simple inputs
    return 'simple';
  }
  if (!Object.keys(inputs).length) {
    // Empty objects can't be maps
    return 'simple';
  }
  for (key in inputs) {
    value = inputs[key];
    if (!network.graph.inports[key]) {
      return 'simple';
    }
  }
  return 'map';
};

prepareInputMap = function(inputs, inputType, network) {
  var inPort, map;
  if (inputType === 'sequence') {
    // Sequence we can use as-is
    return inputs;
  }
  if (inputType === 'map') {
    // We can turn a map to a sequence by wrapping it in an array
    return [inputs];
  }
  // Simple inputs need to be converted to a sequence
  inPort = Object.keys(network.graph.inports)[0];
  if (network.graph.inports.in) {
    // If we have a port named "IN", send to that
    inPort = 'in';
  }
  map = {};
  map[inPort] = inputs;
  return [map];
};

normalizeOutput = function(values, options) {
  var current, i, len, packet, previous, result;
  if (options.raw) {
    return values;
  }
  result = [];
  previous = null;
  current = result;
  for (i = 0, len = values.length; i < len; i++) {
    packet = values[i];
    if (packet.type === 'openBracket') {
      previous = current;
      current = [];
      previous.push(current);
    }
    if (packet.type === 'data') {
      current.push(packet.data);
    }
    if (packet.type === 'closeBracket') {
      current = previous;
    }
  }
  if (result.length === 1) {
    return result[0];
  }
  return result;
};

sendOutputMap = function(outputs, resultType, options, callback) {
  var errors, i, key, len, map, mappedOutputs, outputKeys, packets, port, result, val, withValue;
  // First check if the output sequence contains errors
  errors = outputs.filter(function(map) {
    return map.error != null;
  }).map(function(map) {
    return map.error;
  });
  if (errors.length) {
    return callback(normalizeOutput(errors, options));
  }
  if (resultType === 'sequence') {
    return callback(null, outputs.map(function(map) {
      var key, res, val;
      res = {};
      for (key in map) {
        val = map[key];
        if (options.raw) {
          res[key] = val;
          continue;
        }
        res[key] = normalizeOutput([val], options);
      }
      return res;
    }));
  }
  // Flatten the sequence
  mappedOutputs = {};
  for (i = 0, len = outputs.length; i < len; i++) {
    map = outputs[i];
    for (key in map) {
      val = map[key];
      if (!mappedOutputs[key]) {
        mappedOutputs[key] = [];
      }
      mappedOutputs[key].push(val);
    }
  }
  outputKeys = Object.keys(mappedOutputs);
  withValue = outputKeys.filter(function(outport) {
    return mappedOutputs[outport].length > 0;
  });
  if (withValue.length === 0) {
    // No output
    return callback(null);
  }
  if (withValue.length === 1 && resultType === 'simple') {
    // Single outport
    return callback(null, normalizeOutput(mappedOutputs[withValue[0]], options));
  }
  result = {};
  for (port in mappedOutputs) {
    packets = mappedOutputs[port];
    result[port] = normalizeOutput(packets, options);
  }
  return callback(null, result);
};

exports.asCallback = function(component, options) {
  options = normalizeOptions(options, component);
  return function(inputs, callback) {
    return prepareNetwork(component, options, function(err, network) {
      var inputMap, resultType;
      if (err) {
        return callback(err);
      }
      resultType = getType(inputs, network);
      inputMap = prepareInputMap(inputs, resultType, network);
      return runNetwork(network, inputMap, options, function(err, outputMap) {
        if (err) {
          return callback(err);
        }
        return sendOutputMap(outputMap, resultType, options, callback);
      });
    });
  };
};
