//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2014-2017 Flowhub UG
//     NoFlo may be freely distributed under the MIT license

// Guess language from filename
var createReduce, debounce, guessLanguageFromFilename, isArray, optimizeCb, reduceRight;

guessLanguageFromFilename = function(filename) {
  if (/.*\.coffee$/.test(filename)) {
    return 'coffeescript';
  }
  return 'javascript';
};

isArray = function(obj) {
  if (Array.isArray) {
    return Array.isArray(obj);
  }
  return Object.prototype.toString.call(arg) === '[object Array]';
};

// the following functions are from http://underscorejs.org/docs/underscore.html
// Underscore.js 1.8.3 http://underscorejs.org
// (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
// Underscore may be freely distributed under the MIT license.

// Internal function that returns an efficient (for current engines)
// version of the passed-in callback,
// to be repeatedly applied in other Underscore functions.
optimizeCb = function(func, context, argCount) {
  if (context === void 0) {
    return func;
  }
  switch ((argCount === null ? 3 : argCount)) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 2:
      return function(value, other) {
        return func.call(context, value, other);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
};

// Create a reducing function iterating left or right.
// Optimized iterator function as using arguments.length in the main function
// will deoptimize the, see #1991.
createReduce = function(dir) {
  var iterator;
  iterator = function(obj, iteratee, memo, keys, index, length) {
    var currentKey;
    while (index >= 0 && index < length) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
      index += dir;
    }
    return memo;
  };
  return function(obj, iteratee, memo, context) {
    var index, keys, length;
    iteratee = optimizeCb(iteratee, context, 4);
    keys = Object.keys(obj);
    length = (keys || obj).length;
    index = dir > 0 ? 0 : length - 1;
    if (arguments.length < 3) {
      memo = obj[keys ? keys[index] : index];
      index += dir;
    }
    return iterator(obj, iteratee, memo, keys, index, length);
  };
};

reduceRight = createReduce(-1);

// Returns a function, that, as long as it continues to be invoked,
// will not be triggered.
// The function will be called after it stops being called for N milliseconds.
// If immediate is passed, trigger the function on the leading edge,
// instead of the trailing.
debounce = function(func, wait, immediate) {
  var args, context, later, result, timeout, timestamp;
  timeout = void 0;
  args = void 0;
  context = void 0;
  timestamp = void 0;
  result = void 0;
  later = function() {
    var last;
    last = Date.now - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) {
          context = args = null;
        }
      }
    }
  };
  return function() {
    var callNow;
    context = this;
    args = arguments;
    timestamp = Date.now;
    callNow = immediate && !timeout;
    if (!timeout) {
      timeout = setTimeout(later, wait);
    }
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
};

exports.guessLanguageFromFilename = guessLanguageFromFilename;

exports.reduceRight = reduceRight;

exports.debounce = debounce;

exports.isArray = isArray;
