//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2013-2017 Flowhub UG
//     (c) 2011-2012 Henri Bergius, Nemein
//     NoFlo may be freely distributed under the MIT license
var EventEmitter, IP, Network, componentLoader, graph, internalSocket, platform, utils;

internalSocket = require("./InternalSocket");

graph = require("fbp-graph");

({EventEmitter} = require('events'));

platform = require('./Platform');

componentLoader = require('./ComponentLoader');

utils = require('./Utils');

IP = require('./IP');

Network = (function() {
  // ## The NoFlo network coordinator

  // NoFlo networks consist of processes connected to each other
  // via sockets attached from outports to inports.

  // The role of the network coordinator is to take a graph and
  // instantiate all the necessary processes from the designated
  // components, attach sockets between them, and handle the sending
  // of Initial Information Packets.
  class Network extends EventEmitter {
    // All NoFlo networks are instantiated with a graph. Upon instantiation
    // they will load all the needed components, instantiate them, and
    // set up the defined connections and IIPs.

    // The network will also listen to graph changes and modify itself
    // accordingly, including removing connections, adding new nodes,
    // and sending new IIPs.
    constructor(graph, options = {}) {
      super();
      this.options = options;
      this.processes = {};
      this.connections = [];
      this.initials = [];
      this.nextInitials = [];
      this.defaults = [];
      this.graph = graph;
      this.started = false;
      this.stopped = true;
      this.debug = true;
      this.eventBuffer = [];
      // On Node.js we default the baseDir for component loading to
      // the current working directory
      if (!platform.isBrowser()) {
        this.baseDir = graph.baseDir || process.cwd();
      } else {
        // On browser we default the baseDir to the Component loading
        // root
        this.baseDir = graph.baseDir || '/';
      }
      // As most NoFlo networks are long-running processes, the
      // network coordinator marks down the start-up time. This
      // way we can calculate the uptime of the network.
      this.startupDate = null;
      // Initialize a Component Loader for the network
      if (graph.componentLoader) {
        this.loader = graph.componentLoader;
      } else {
        this.loader = new componentLoader.ComponentLoader(this.baseDir, this.options);
      }
    }

    // The uptime of the network is the current time minus the start-up
    // time, in seconds.
    uptime() {
      if (!this.startupDate) {
        return 0;
      }
      return new Date() - this.startupDate;
    }

    getActiveProcesses() {
      var active, name, process, ref;
      active = [];
      if (!this.started) {
        return active;
      }
      ref = this.processes;
      for (name in ref) {
        process = ref[name];
        if (process.component.load > 0) {
          // Modern component with load
          active.push(name);
        }
        if (process.component.__openConnections > 0) {
          // Legacy component
          active.push(name);
        }
      }
      return active;
    }

    bufferedEmit(event, payload) {
      var ev, i, len, ref;
      // Errors get emitted immediately, like does network end
      if (event === 'icon' || event === 'error' || event === 'process-error' || event === 'end') {
        this.emit(event, payload);
        return;
      }
      if (!this.isStarted() && event !== 'end') {
        this.eventBuffer.push({
          type: event,
          payload: payload
        });
        return;
      }
      this.emit(event, payload);
      if (event === 'start') {
        ref = this.eventBuffer;
        // Once network has started we can send the IP-related events
        for (i = 0, len = ref.length; i < len; i++) {
          ev = ref[i];
          this.emit(ev.type, ev.payload);
        }
        this.eventBuffer = [];
      }
      if (event === 'ip') {
        // Emit also the legacy events from IP
        switch (payload.type) {
          case 'openBracket':
            this.bufferedEmit('begingroup', payload);
            break;
          case 'closeBracket':
            this.bufferedEmit('endgroup', payload);
            break;
          case 'data':
            this.bufferedEmit('data', payload);
        }
      }
    }

    // ## Loading components

    // Components can be passed to the NoFlo network in two ways:

    // * As direct, instantiated JavaScript objects
    // * As filenames
    load(component, metadata, callback) {
      return this.loader.load(component, callback, metadata);
    }

    // ## Add a process to the network

    // Processes can be added to a network at either start-up time
    // or later. The processes are added with a node definition object
    // that includes the following properties:

    // * `id`: Identifier of the process in the network. Typically a string
    // * `component`: Filename or path of a NoFlo component, or a component instance object
    addNode(node, callback) {
      var process;
      // Processes are treated as singletons by their identifier. If
      // we already have a process with the given ID, return that.
      if (this.processes[node.id]) {
        callback(null, this.processes[node.id]);
        return;
      }
      process = {
        id: node.id
      };
      // No component defined, just register the process but don't start.
      if (!node.component) {
        this.processes[process.id] = process;
        callback(null, process);
        return;
      }
      // Load the component for the process.
      return this.load(node.component, node.metadata, (err, instance) => {
        var inPorts, name, outPorts, port;
        if (err) {
          return callback(err);
        }
        instance.nodeId = node.id;
        process.component = instance;
        process.componentName = node.component;
        // Inform the ports of the node name
        inPorts = process.component.inPorts.ports;
        outPorts = process.component.outPorts.ports;
        for (name in inPorts) {
          port = inPorts[name];
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        for (name in outPorts) {
          port = outPorts[name];
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        if (instance.isSubgraph()) {
          this.subscribeSubgraph(process);
        }
        this.subscribeNode(process);
        // Store and return the process instance
        this.processes[process.id] = process;
        return callback(null, process);
      });
    }

    removeNode(node, callback) {
      var process;
      process = this.getNode(node.id);
      if (!process) {
        return callback(new Error(`Node ${node.id} not found`));
      }
      return process.component.shutdown((err) => {
        if (err) {
          return callback(err);
        }
        delete this.processes[node.id];
        return callback(null);
      });
    }

    renameNode(oldId, newId, callback) {
      var inPorts, name, outPorts, port, process;
      process = this.getNode(oldId);
      if (!process) {
        return callback(new Error(`Process ${oldId} not found`));
      }
      // Inform the process of its ID
      process.id = newId;
      // Inform the ports of the node name
      inPorts = process.component.inPorts.ports;
      outPorts = process.component.outPorts.ports;
      for (name in inPorts) {
        port = inPorts[name];
        if (!port) {
          continue;
        }
        port.node = newId;
      }
      for (name in outPorts) {
        port = outPorts[name];
        if (!port) {
          continue;
        }
        port.node = newId;
      }
      this.processes[newId] = process;
      delete this.processes[oldId];
      return callback(null);
    }

    // Get process by its ID.
    getNode(id) {
      return this.processes[id];
    }

    connect(done = function() {}) {
      var callStack, edges, initializers, nodes, serialize, setDefaults, subscribeGraph;
      // Wrap the future which will be called when done in a function and return
      // it
      callStack = 0;
      serialize = (next, add) => {
        return (type) => {
          // Add either a Node, an Initial, or an Edge and move on to the next one
          // when done
          return this[`add${type}`](add, function(err) {
            if (err) {
              return done(err);
            }
            callStack++;
            if (callStack % 100 === 0) {
              setTimeout(function() {
                return next(type);
              }, 0);
              return;
            }
            return next(type);
          });
        };
      };
      // Subscribe to graph changes when everything else is done
      subscribeGraph = () => {
        this.subscribeGraph();
        return done();
      };
      // Serialize default socket creation then call callback when done
      setDefaults = utils.reduceRight(this.graph.nodes, serialize, subscribeGraph);
      // Serialize initializers then call defaults.
      initializers = utils.reduceRight(this.graph.initializers, serialize, function() {
        return setDefaults("Defaults");
      });
      // Serialize edge creators then call the initializers.
      edges = utils.reduceRight(this.graph.edges, serialize, function() {
        return initializers("Initial");
      });
      // Serialize node creators then call the edge creators
      nodes = utils.reduceRight(this.graph.nodes, serialize, function() {
        return edges("Edge");
      });
      // Start with node creators
      return nodes("Node");
    }

    connectPort(socket, process, port, index, inbound, callback) {
      if (inbound) {
        socket.to = {
          process: process,
          port: port,
          index: index
        };
        if (!(process.component.inPorts && process.component.inPorts[port])) {
          callback(new Error(`No inport '${port}' defined in process ${process.id} (${socket.getId()})`));
          return;
        }
        if (process.component.inPorts[port].isAddressable()) {
          process.component.inPorts[port].attach(socket, index);
          callback();
          return;
        }
        process.component.inPorts[port].attach(socket);
        callback();
        return;
      }
      socket.from = {
        process: process,
        port: port,
        index: index
      };
      if (!(process.component.outPorts && process.component.outPorts[port])) {
        callback(new Error(`No outport '${port}' defined in process ${process.id} (${socket.getId()})`));
        return;
      }
      if (process.component.outPorts[port].isAddressable()) {
        process.component.outPorts[port].attach(socket, index);
        callback();
        return;
      }
      process.component.outPorts[port].attach(socket);
      callback();
    }

    subscribeGraph() {
      var graphOps, processOps, processing, registerOp;
      // A NoFlo graph may change after network initialization.
      // For this, the network subscribes to the change events from
      // the graph.

      // In graph we talk about nodes and edges. Nodes correspond
      // to NoFlo processes, and edges to connections between them.
      graphOps = [];
      processing = false;
      registerOp = function(op, details) {
        return graphOps.push({
          op: op,
          details: details
        });
      };
      processOps = (err) => {
        var cb, op;
        if (err) {
          if (this.listeners('process-error').length === 0) {
            throw err;
          }
          this.bufferedEmit('process-error', err);
        }
        if (!graphOps.length) {
          processing = false;
          return;
        }
        processing = true;
        op = graphOps.shift();
        cb = processOps;
        switch (op.op) {
          case 'renameNode':
            return this.renameNode(op.details.from, op.details.to, cb);
          default:
            return this[op.op](op.details, cb);
        }
      };
      this.graph.on('addNode', function(node) {
        registerOp('addNode', node);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('removeNode', function(node) {
        registerOp('removeNode', node);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('renameNode', function(oldId, newId) {
        registerOp('renameNode', {
          from: oldId,
          to: newId
        });
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('addEdge', function(edge) {
        registerOp('addEdge', edge);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('removeEdge', function(edge) {
        registerOp('removeEdge', edge);
        if (!processing) {
          return processOps();
        }
      });
      this.graph.on('addInitial', function(iip) {
        registerOp('addInitial', iip);
        if (!processing) {
          return processOps();
        }
      });
      return this.graph.on('removeInitial', function(iip) {
        registerOp('removeInitial', iip);
        if (!processing) {
          return processOps();
        }
      });
    }

    subscribeSubgraph(node) {
      var emitSub;
      if (!node.component.isReady()) {
        node.component.once('ready', () => {
          return this.subscribeSubgraph(node);
        });
        return;
      }
      if (!node.component.network) {
        return;
      }
      node.component.network.setDebug(this.debug);
      emitSub = (type, data) => {
        if (type === 'process-error' && this.listeners('process-error').length === 0) {
          if (data.id && data.metadata && data.error) {
            throw data.error;
          }
          throw data;
        }
        if (!data) {
          data = {};
        }
        if (data.subgraph) {
          if (!data.subgraph.unshift) {
            data.subgraph = [data.subgraph];
          }
          data.subgraph.unshift(node.id);
        } else {
          data.subgraph = [node.id];
        }
        return this.bufferedEmit(type, data);
      };
      node.component.network.on('ip', function(data) {
        return emitSub('ip', data);
      });
      return node.component.network.on('process-error', function(data) {
        return emitSub('process-error', data);
      });
    }

    // Subscribe to events from all connected sockets and re-emit them
    subscribeSocket(socket, source) {
      var ref;
      socket.on('ip', (ip) => {
        return this.bufferedEmit('ip', {
          id: socket.getId(),
          type: ip.type,
          socket: socket,
          data: ip.data,
          metadata: socket.metadata
        });
      });
      socket.on('error', (event) => {
        if (this.listeners('process-error').length === 0) {
          if (event.id && event.metadata && event.error) {
            throw event.error;
          }
          throw event;
        }
        return this.bufferedEmit('process-error', event);
      });
      if (!(source != null ? (ref = source.component) != null ? ref.isLegacy() : void 0 : void 0)) {
        return;
      }
      // Handle activation for legacy components via connects/disconnects
      socket.on('connect', function() {
        if (!source.component.__openConnections) {
          source.component.__openConnections = 0;
        }
        return source.component.__openConnections++;
      });
      return socket.on('disconnect', () => {
        source.component.__openConnections--;
        if (source.component.__openConnections < 0) {
          source.component.__openConnections = 0;
        }
        if (source.component.__openConnections === 0) {
          return this.checkIfFinished();
        }
      });
    }

    subscribeNode(node) {
      node.component.on('activate', (load) => {
        if (this.debouncedEnd) {
          return this.abortDebounce = true;
        }
      });
      node.component.on('deactivate', (load) => {
        if (load > 0) {
          return;
        }
        return this.checkIfFinished();
      });
      if (!node.component.getIcon) {
        return;
      }
      return node.component.on('icon', () => {
        return this.bufferedEmit('icon', {
          id: node.id,
          icon: node.component.getIcon()
        });
      });
    }

    addEdge(edge, callback) {
      var from, socket, to;
      socket = internalSocket.createSocket(edge.metadata);
      socket.setDebug(this.debug);
      from = this.getNode(edge.from.node);
      if (!from) {
        return callback(new Error(`No process defined for outbound node ${edge.from.node}`));
      }
      if (!from.component) {
        return callback(new Error(`No component defined for outbound node ${edge.from.node}`));
      }
      if (!from.component.isReady()) {
        from.component.once("ready", () => {
          return this.addEdge(edge, callback);
        });
        return;
      }
      to = this.getNode(edge.to.node);
      if (!to) {
        return callback(new Error(`No process defined for inbound node ${edge.to.node}`));
      }
      if (!to.component) {
        return callback(new Error(`No component defined for inbound node ${edge.to.node}`));
      }
      if (!to.component.isReady()) {
        to.component.once("ready", () => {
          return this.addEdge(edge, callback);
        });
        return;
      }
      // Subscribe to events from the socket
      this.subscribeSocket(socket, from);
      return this.connectPort(socket, to, edge.to.port, edge.to.index, true, (err) => {
        if (err) {
          return callback(err);
        }
        return this.connectPort(socket, from, edge.from.port, edge.from.index, false, (err) => {
          if (err) {
            return callback(err);
          }
          this.connections.push(socket);
          return callback();
        });
      });
    }

    removeEdge(edge, callback) {
      var connection, i, len, ref, results;
      ref = this.connections;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        connection = ref[i];
        if (!connection) {
          continue;
        }
        if (!(edge.to.node === connection.to.process.id && edge.to.port === connection.to.port)) {
          continue;
        }
        connection.to.process.component.inPorts[connection.to.port].detach(connection);
        if (edge.from.node) {
          if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
            connection.from.process.component.outPorts[connection.from.port].detach(connection);
          }
        }
        this.connections.splice(this.connections.indexOf(connection), 1);
        results.push(callback());
      }
      return results;
    }

    addDefaults(node, callback) {
      var key, port, process, ref, socket;
      process = this.getNode(node.id);
      if (!process) {
        return callback(new Error(`Process ${node.id} not defined`));
      }
      if (!process.component) {
        return callback(new Error(`No component defined for node ${node.id}`));
      }
      if (!process.component.isReady()) {
        process.component.setMaxListeners(0);
        process.component.once("ready", () => {
          return this.addDefaults(process, callback);
        });
        return;
      }
      ref = process.component.inPorts.ports;
      for (key in ref) {
        port = ref[key];
        // Attach a socket to any defaulted inPorts as long as they aren't already attached.
        if (port.hasDefault() && !port.isAttached()) {
          socket = internalSocket.createSocket();
          socket.setDebug(this.debug);
          // Subscribe to events from the socket
          this.subscribeSocket(socket);
          this.connectPort(socket, process, key, void 0, true, function() {});
          this.connections.push(socket);
          this.defaults.push(socket);
        }
      }
      return callback();
    }

    addInitial(initializer, callback) {
      var socket, to;
      socket = internalSocket.createSocket(initializer.metadata);
      socket.setDebug(this.debug);
      // Subscribe to events from the socket
      this.subscribeSocket(socket);
      to = this.getNode(initializer.to.node);
      if (!to) {
        return callback(new Error(`No process defined for inbound node ${initializer.to.node}`));
      }
      if (!to.component) {
        return callback(new Error(`No component defined for inbound node ${initializer.to.node}`));
      }
      if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
        to.component.setMaxListeners(0);
        to.component.once("ready", () => {
          return this.addInitial(initializer, callback);
        });
        return;
      }
      return this.connectPort(socket, to, initializer.to.port, initializer.to.index, true, (err) => {
        var init;
        if (err) {
          return callback(err);
        }
        this.connections.push(socket);
        init = {
          socket: socket,
          data: initializer.from.data
        };
        this.initials.push(init);
        this.nextInitials.push(init);
        if (this.isRunning()) {
          // Network is running now, send initials immediately
          this.sendInitials();
        } else if (!this.isStopped()) {
          // Network has finished but hasn't been stopped, set
          // started and set
          this.setStarted(true);
          this.sendInitials();
        }
        return callback();
      });
    }

    removeInitial(initializer, callback) {
      var connection, i, init, j, k, len, len1, len2, ref, ref1, ref2;
      ref = this.connections;
      for (i = 0, len = ref.length; i < len; i++) {
        connection = ref[i];
        if (!connection) {
          continue;
        }
        if (!(initializer.to.node === connection.to.process.id && initializer.to.port === connection.to.port)) {
          continue;
        }
        connection.to.process.component.inPorts[connection.to.port].detach(connection);
        this.connections.splice(this.connections.indexOf(connection), 1);
        ref1 = this.initials;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          init = ref1[j];
          if (!init) {
            continue;
          }
          if (init.socket !== connection) {
            continue;
          }
          this.initials.splice(this.initials.indexOf(init), 1);
        }
        ref2 = this.nextInitials;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          init = ref2[k];
          if (!init) {
            continue;
          }
          if (init.socket !== connection) {
            continue;
          }
          this.nextInitials.splice(this.nextInitials.indexOf(init), 1);
        }
      }
      return callback();
    }

    sendInitial(initial) {
      return initial.socket.post(new IP('data', initial.data, {
        initial: true
      }));
    }

    sendInitials(callback) {
      var send;
      if (!callback) {
        callback = function() {};
      }
      send = () => {
        var i, initial, len, ref;
        ref = this.initials;
        for (i = 0, len = ref.length; i < len; i++) {
          initial = ref[i];
          this.sendInitial(initial);
        }
        this.initials = [];
        return callback();
      };
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        // nextTick is faster on Node.js
        return process.nextTick(send);
      } else {
        return setTimeout(send, 0);
      }
    }

    isStarted() {
      return this.started;
    }

    isStopped() {
      return this.stopped;
    }

    isRunning() {
      return this.getActiveProcesses().length > 0;
    }

    startComponents(callback) {
      var count, id, length, onProcessStart, process, ref, results;
      if (!callback) {
        callback = function() {};
      }
      // Emit start event when all processes are started
      count = 0;
      length = this.processes ? Object.keys(this.processes).length : 0;
      onProcessStart = function(err) {
        if (err) {
          return callback(err);
        }
        count++;
        if (count === length) {
          return callback();
        }
      };
      if (!(this.processes && Object.keys(this.processes).length)) {
        // Perform any startup routines necessary for every component.
        return callback();
      }
      ref = this.processes;
      results = [];
      for (id in ref) {
        process = ref[id];
        if (process.component.isStarted()) {
          onProcessStart();
          continue;
        }
        if (process.component.start.length === 0) {
          platform.deprecated('component.start method without callback is deprecated');
          process.component.start();
          onProcessStart();
          continue;
        }
        results.push(process.component.start(onProcessStart));
      }
      return results;
    }

    sendDefaults(callback) {
      var i, len, ref, socket;
      if (!callback) {
        callback = function() {};
      }
      if (!this.defaults.length) {
        return callback();
      }
      ref = this.defaults;
      for (i = 0, len = ref.length; i < len; i++) {
        socket = ref[i];
        if (socket.to.process.component.inPorts[socket.to.port].sockets.length !== 1) {
          // Don't send defaults if more than one socket is present on the port.
          // This case should only happen when a subgraph is created as a component
          // as its network is instantiated and its inputs are serialized before
          // a socket is attached from the "parent" graph.
          continue;
        }
        socket.connect();
        socket.send();
        socket.disconnect();
      }
      return callback();
    }

    start(callback) {
      if (!callback) {
        platform.deprecated('Calling network.start() without callback is deprecated');
        callback = function() {};
      }
      if (this.debouncedEnd) {
        this.abortDebounce = true;
      }
      if (this.started) {
        this.stop((err) => {
          if (err) {
            return callback(err);
          }
          return this.start(callback);
        });
        return;
      }
      this.initials = this.nextInitials.slice(0);
      this.eventBuffer = [];
      this.startComponents((err) => {
        if (err) {
          return callback(err);
        }
        this.sendInitials((err) => {
          if (err) {
            return callback(err);
          }
          this.sendDefaults((err) => {
            if (err) {
              return callback(err);
            }
            this.setStarted(true);
            callback(null);
          });
        });
      });
    }

    stop(callback) {
      var connection, count, i, id, len, length, onProcessEnd, process, ref, ref1, results;
      if (!callback) {
        platform.deprecated('Calling network.stop() without callback is deprecated');
        callback = function() {};
      }
      if (this.debouncedEnd) {
        this.abortDebounce = true;
      }
      if (!this.started) {
        this.stopped = true;
        return callback(null);
      }
      ref = this.connections;
      // Disconnect all connections
      for (i = 0, len = ref.length; i < len; i++) {
        connection = ref[i];
        if (!connection.isConnected()) {
          continue;
        }
        connection.disconnect();
      }
      // Emit stop event when all processes are stopped
      count = 0;
      length = this.processes ? Object.keys(this.processes).length : 0;
      onProcessEnd = (err) => {
        if (err) {
          return callback(err);
        }
        count++;
        if (count === length) {
          this.setStarted(false);
          this.stopped = true;
          return callback();
        }
      };
      if (!(this.processes && Object.keys(this.processes).length)) {
        this.setStarted(false);
        this.stopped = true;
        return callback();
      }
      ref1 = this.processes;
      // Tell processes to shut down
      results = [];
      for (id in ref1) {
        process = ref1[id];
        if (!process.component.isStarted()) {
          onProcessEnd();
          continue;
        }
        if (process.component.shutdown.length === 0) {
          platform.deprecated('component.shutdown method without callback is deprecated');
          process.component.shutdown();
          onProcessEnd();
          continue;
        }
        results.push(process.component.shutdown(onProcessEnd));
      }
      return results;
    }

    setStarted(started) {
      if (this.started === started) {
        return;
      }
      if (!started) {
        // Ending the execution
        this.started = false;
        this.bufferedEmit('end', {
          start: this.startupDate,
          end: new Date,
          uptime: this.uptime()
        });
        return;
      }
      if (!this.startupDate) {
        // Starting the execution
        this.startupDate = new Date;
      }
      this.started = true;
      this.stopped = false;
      return this.bufferedEmit('start', {
        start: this.startupDate
      });
    }

    checkIfFinished() {
      if (this.isRunning()) {
        return;
      }
      delete this.abortDebounce;
      if (!this.debouncedEnd) {
        this.debouncedEnd = utils.debounce(() => {
          if (this.abortDebounce) {
            return;
          }
          if (this.isRunning()) {
            return;
          }
          return this.setStarted(false);
        }, 50);
      }
      return this.debouncedEnd();
    }

    getDebug() {
      return this.debug;
    }

    setDebug(active) {
      var i, instance, len, process, processId, ref, ref1, results, socket;
      if (active === this.debug) {
        return;
      }
      this.debug = active;
      ref = this.connections;
      for (i = 0, len = ref.length; i < len; i++) {
        socket = ref[i];
        socket.setDebug(active);
      }
      ref1 = this.processes;
      results = [];
      for (processId in ref1) {
        process = ref1[processId];
        instance = process.component;
        if (instance.isSubgraph()) {
          results.push(instance.network.setDebug(active));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

  };

  // Processes contains all the instantiated components for this network
  Network.prototype.processes = {};

  // Connections contains all the socket connections in the network
  Network.prototype.connections = [];

  // Initials contains all Initial Information Packets (IIPs)
  Network.prototype.initials = [];

  // Container to hold sockets that will be sending default data.
  Network.prototype.defaults = [];

  // The Graph this network is instantiated with
  Network.prototype.graph = null;

  // Start-up timestamp for the network, used for calculating uptime
  Network.prototype.startupDate = null;

  return Network;

}).call(this);

exports.Network = Network;
