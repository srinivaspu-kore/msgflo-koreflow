  //     NoFlo - Flow-Based Programming for JavaScript
  //     (c) 2013-2017 Flowhub UG
  //     (c) 2011-2012 Henri Bergius, Nemein
  //     NoFlo may be freely distributed under the MIT license
var Component, EventEmitter, IP, ProcessContext, ProcessInput, ProcessOutput, debug, debugBrackets, debugSend, ports,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

({EventEmitter} = require('events'));

ports = require('./Ports');

IP = require('./IP');

debug = require('debug')('noflo:component');

debugBrackets = require('debug')('noflo:component:brackets');

debugSend = require('debug')('noflo:component:send');

Component = (function() {
  // ## NoFlo Component Base class

  // The `noflo.Component` interface provides a way to instantiate
  // and extend NoFlo components.
  class Component extends EventEmitter {
    constructor(options) {
      var ref, ref1, ref2;
      super();
      // ### Error emitting helper

      // If component has an `error` outport that is connected, errors
      // are sent as IP objects there. If the port is not connected,
      // errors are thrown.
      this.error = this.error.bind(this);
      if (!options) {
        options = {};
      }
      if (!options.inPorts) {
        // Prepare inports, if any were given in options.
        // They can also be set up imperatively after component
        // instantiation by using the `component.inPorts.add`
        // method.
        options.inPorts = {};
      }
      if (options.inPorts instanceof ports.InPorts) {
        this.inPorts = options.inPorts;
      } else {
        this.inPorts = new ports.InPorts(options.inPorts);
      }
      if (!options.outPorts) {
        // Prepare outports, if any were given in options.
        // They can also be set up imperatively after component
        // instantiation by using the `component.outPorts.add`
        // method.
        options.outPorts = {};
      }
      if (options.outPorts instanceof ports.OutPorts) {
        this.outPorts = options.outPorts;
      } else {
        this.outPorts = new ports.OutPorts(options.outPorts);
      }
      if (options.icon) {
        // Set the default component icon and description
        this.icon = options.icon;
      }
      if (options.description) {
        this.description = options.description;
      }
      // Initially the component is not started
      this.started = false;
      this.load = 0;
      // Whether the component should keep send packets
      // out in the order they were received
      this.ordered = (ref = options.ordered) != null ? ref : false;
      this.autoOrdering = (ref1 = options.autoOrdering) != null ? ref1 : null;
      // Queue for handling ordered output packets
      this.outputQ = [];
      // Context used for bracket forwarding
      this.bracketContext = {
        in: {},
        out: {}
      };
      // Whether the component should activate when it
      // receives packets
      this.activateOnInput = (ref2 = options.activateOnInput) != null ? ref2 : true;
      // Bracket forwarding rules. By default we forward
      // brackets from `in` port to `out` and `error` ports.
      this.forwardBrackets = {
        in: ['out', 'error']
      };
      if ('forwardBrackets' in options) {
        this.forwardBrackets = options.forwardBrackets;
      }
      // The component's process function can either be
      // passed in options, or given imperatively after
      // instantation using the `component.process` method.
      if (typeof options.process === 'function') {
        this.process(options.process);
      }
    }

    getDescription() {
      return this.description;
    }

    isReady() {
      return true;
    }

    isSubgraph() {
      return false;
    }

    setIcon(icon) {
      this.icon = icon;
      return this.emit('icon', this.icon);
    }

    getIcon() {
      return this.icon;
    }

    error(e, groups = [], errorPort = 'error', scope = null) {
      var group, i, j, len1, len2;
      boundMethodCheck(this, Component);
      if (this.outPorts[errorPort] && (this.outPorts[errorPort].isAttached() || !this.outPorts[errorPort].isRequired())) {
        for (i = 0, len1 = groups.length; i < len1; i++) {
          group = groups[i];
          this.outPorts[errorPort].openBracket(group, {
            scope: scope
          });
        }
        this.outPorts[errorPort].data(e, {
          scope: scope
        });
        for (j = 0, len2 = groups.length; j < len2; j++) {
          group = groups[j];
          this.outPorts[errorPort].closeBracket(group, {
            scope: scope
          });
        }
        return;
      }
      throw e;
    }

    // ### Setup

    // The setUp method is for component-specific initialization.
    // Called at network start-up.

    // Override in component implementation to do component-specific
    // setup work.
    setUp(callback) {
      callback();
    }

    // ### Setup

    // The tearDown method is for component-specific cleanup. Called
    // at network shutdown

    // Override in component implementation to do component-specific
    // cleanup work, like clearing any accumulated state.
    tearDown(callback) {
      callback();
    }

    // ### Start

    // Called when network starts. This sets calls the setUp
    // method and sets the component to a started state.
    start(callback) {
      if (this.isStarted()) {
        return callback();
      }
      this.setUp((err) => {
        if (err) {
          return callback(err);
        }
        this.started = true;
        this.emit('start');
        callback(null);
      });
    }

    // ### Shutdown

    // Called when network is shut down. This sets calls the
    // tearDown method and sets the component back to a
    // non-started state.

    // The callback is called when tearDown finishes and
    // all active processing contexts have ended.
    shutdown(callback) {
      var finalize;
      finalize = () => {
        var inPort, inPorts, portName;
        // Clear contents of inport buffers
        inPorts = this.inPorts.ports || this.inPorts;
        for (portName in inPorts) {
          inPort = inPorts[portName];
          if (typeof inPort.clear !== 'function') {
            continue;
          }
          inPort.clear();
        }
        // Clear bracket context
        this.bracketContext = {
          in: {},
          out: {}
        };
        if (!this.isStarted()) {
          return callback();
        }
        this.started = false;
        this.emit('end');
        callback();
      };
      // Tell the component that it is time to shut down
      this.tearDown((err) => {
        var checkLoad;
        if (err) {
          return callback(err);
        }
        if (this.load > 0) {
          // Some in-flight processes, wait for them to finish
          checkLoad = function(load) {
            if (load > 0) {
              return;
            }
            this.removeListener('deactivate', checkLoad);
            finalize();
          };
          this.on('deactivate', checkLoad);
          return;
        }
        finalize();
      });
    }

    isStarted() {
      return this.started;
    }

    // Ensures braket forwarding map is correct for the existing ports
    prepareForwarding() {
      var i, inPort, len1, outPort, outPorts, ref, results, tmp;
      ref = this.forwardBrackets;
      results = [];
      for (inPort in ref) {
        outPorts = ref[inPort];
        if (!(inPort in this.inPorts.ports)) {
          delete this.forwardBrackets[inPort];
          continue;
        }
        tmp = [];
        for (i = 0, len1 = outPorts.length; i < len1; i++) {
          outPort = outPorts[i];
          if (outPort in this.outPorts.ports) {
            tmp.push(outPort);
          }
        }
        if (tmp.length === 0) {
          results.push(delete this.forwardBrackets[inPort]);
        } else {
          results.push(this.forwardBrackets[inPort] = tmp);
        }
      }
      return results;
    }

    // Method for determining if a component is using the modern
    // NoFlo Process API
    isLegacy() {
      if (this.handle) {
        // Process API
        return false;
      }
      // Legacy
      return true;
    }

    // Sets process handler function
    process(handle) {
      var name, port, ref;
      if (typeof handle !== 'function') {
        throw new Error("Process handler must be a function");
      }
      if (!this.inPorts) {
        throw new Error("Component ports must be defined before process function");
      }
      this.prepareForwarding();
      this.handle = handle;
      ref = this.inPorts.ports;
      for (name in ref) {
        port = ref[name];
        ((name, port) => {
          if (!port.name) {
            port.name = name;
          }
          return port.on('ip', (ip) => {
            return this.handleIP(ip, port);
          });
        })(name, port);
      }
      return this;
    }

    // Method for checking if a given inport is set up for
    // automatic bracket forwarding
    isForwardingInport(port) {
      var portName;
      if (typeof port === 'string') {
        portName = port;
      } else {
        portName = port.name;
      }
      if (portName in this.forwardBrackets) {
        return true;
      }
      return false;
    }

    // Method for checking if a given outport is set up for
    // automatic bracket forwarding
    isForwardingOutport(inport, outport) {
      var inportName, outportName;
      if (typeof inport === 'string') {
        inportName = inport;
      } else {
        inportName = inport.name;
      }
      if (typeof outport === 'string') {
        outportName = outport;
      } else {
        outportName = outport.name;
      }
      if (!this.forwardBrackets[inportName]) {
        return false;
      }
      if (this.forwardBrackets[inportName].indexOf(outportName) !== -1) {
        return true;
      }
      return false;
    }

    // Method for checking whether the component sends packets
    // in the same order they were received.
    isOrdered() {
      if (this.ordered) {
        return true;
      }
      if (this.autoOrdering) {
        return true;
      }
      return false;
    }

    // ### Handling IP objects

    // The component has received an Information Packet. Call the
    // processing function so that firing pattern preconditions can
    // be checked and component can do processing as needed.
    handleIP(ip, port) {
      var buf, context, dataPackets, e, input, output, result;
      if (!port.options.triggering) {
        return;
      }
      // If port is non-triggering, we can skip the process function call
      if (ip.type === 'openBracket' && this.autoOrdering === null && !this.ordered) {
        // Switch component to ordered mode when receiving a stream unless
        // auto-ordering is disabled
        debug(`${this.nodeId} port '${port.name}' entered auto-ordering mode`);
        this.autoOrdering = true;
      }
      // Initialize the result object for situations where output needs
      // to be queued to be kept in order
      result = {};
      if (this.isForwardingInport(port)) {
        // For bracket-forwarding inports we need to initialize a bracket context
        // so that brackets can be sent as part of the output, and closed after.
        if (ip.type === 'openBracket') {
          return;
        }
        // For forwarding ports openBrackets don't fire
        if (ip.type === 'closeBracket') {
          // For forwarding ports closeBrackets don't fire
          // However, we need to handle several different scenarios:
          // A. There are closeBrackets in queue before current packet
          // B. There are closeBrackets in queue after current packet
          // C. We've queued the results from all in-flight processes and
          //    new closeBracket arrives
          buf = port.getBuffer(ip.scope, ip.index);
          dataPackets = buf.filter(function(ip) {
            return ip.type === 'data';
          });
          if (this.outputQ.length >= this.load && dataPackets.length === 0) {
            if (buf[0] !== ip) {
              return;
            }
            // Remove from buffer
            port.get(ip.scope, ip.index);
            context = this.getBracketContext('in', port.name, ip.scope, ip.index).pop();
            context.closeIp = ip;
            debugBrackets(`${this.nodeId} closeBracket-C from '${context.source}' to ${context.ports}: '${ip.data}'`);
            result = {
              __resolved: true,
              __bracketClosingAfter: [context]
            };
            this.outputQ.push(result);
            this.processOutputQueue();
          }
          // Check if buffer contains data IPs. If it does, we want to allow
          // firing
          if (!dataPackets.length) {
            return;
          }
        }
      }
      // Prepare the input/output pair
      context = new ProcessContext(ip, this, port, result);
      input = new ProcessInput(this.inPorts, context);
      output = new ProcessOutput(this.outPorts, context);
      try {
        // Call the processing function
        this.handle(input, output, context);
      } catch (error1) {
        e = error1;
        this.deactivate(context);
        output.sendDone(e);
      }
      if (context.activated) {
        return;
      }
      // If receiving an IP object didn't cause the component to
      // activate, log that input conditions were not met
      if (port.isAddressable()) {
        debug(`${this.nodeId} packet on '${port.name}[${ip.index}]' didn't match preconditions: ${ip.type}`);
        return;
      }
      debug(`${this.nodeId} packet on '${port.name}' didn't match preconditions: ${ip.type}`);
    }

    // Get the current bracket forwarding context for an IP object
    getBracketContext(type, port, scope, idx) {
      var index, name, portsList;
      ({name, index} = ports.normalizePortName(port));
      if (idx != null) {
        index = idx;
      }
      portsList = type === 'in' ? this.inPorts : this.outPorts;
      if (portsList[name].isAddressable()) {
        port = `${name}[${index}]`;
      }
      if (!this.bracketContext[type][port]) {
        // Ensure we have a bracket context for the current scope
        this.bracketContext[type][port] = {};
      }
      if (!this.bracketContext[type][port][scope]) {
        this.bracketContext[type][port][scope] = [];
      }
      return this.bracketContext[type][port][scope];
    }

    // Add an IP object to the list of results to be sent in
    // order
    addToResult(result, port, ip, before = false) {
      var idx, index, method, name;
      ({name, index} = ports.normalizePortName(port));
      method = before ? 'unshift' : 'push';
      if (this.outPorts[name].isAddressable()) {
        idx = index ? parseInt(index) : ip.index;
        if (!result[name]) {
          result[name] = {};
        }
        if (!result[name][idx]) {
          result[name][idx] = [];
        }
        ip.index = idx;
        result[name][idx][method](ip);
        return;
      }
      if (!result[name]) {
        result[name] = [];
      }
      return result[name][method](ip);
    }

    // Get contexts that can be forwarded with this in/outport
    // pair.
    getForwardableContexts(inport, outport, contexts) {
      var forwardable, index, name;
      ({name, index} = ports.normalizePortName(outport));
      forwardable = [];
      contexts.forEach((ctx, idx) => {
        var outContext;
        // No forwarding to this outport
        if (!this.isForwardingOutport(inport, name)) {
          return;
        }
        // We have already forwarded this context to this outport
        if (ctx.ports.indexOf(outport) !== -1) {
          return;
        }
        // See if we have already forwarded the same bracket from another
        // inport
        outContext = this.getBracketContext('out', name, ctx.ip.scope, index)[idx];
        if (outContext) {
          if (outContext.ip.data === ctx.ip.data && outContext.ports.indexOf(outport) !== -1) {
            return;
          }
        }
        return forwardable.push(ctx);
      });
      return forwardable;
    }

    // Add any bracket forwards needed to the result queue
    addBracketForwards(result) {
      var context, i, ipClone, j, k, l, len1, len2, len3, len4, port, ref, ref1, ref2, ref3, ref4, ref5;
      if ((ref = result.__bracketClosingBefore) != null ? ref.length : void 0) {
        ref1 = result.__bracketClosingBefore;
        for (i = 0, len1 = ref1.length; i < len1; i++) {
          context = ref1[i];
          debugBrackets(`${this.nodeId} closeBracket-A from '${context.source}' to ${context.ports}: '${context.closeIp.data}'`);
          if (!context.ports.length) {
            continue;
          }
          ref2 = context.ports;
          for (j = 0, len2 = ref2.length; j < len2; j++) {
            port = ref2[j];
            ipClone = context.closeIp.clone();
            this.addToResult(result, port, ipClone, true);
            this.getBracketContext('out', port, ipClone.scope).pop();
          }
        }
      }
      if (result.__bracketContext) {
        // First see if there are any brackets to forward. We need to reverse
        // the keys so that they get added in correct order
        Object.keys(result.__bracketContext).reverse().forEach((inport) => {
          var ctx, datas, forwardedOpens, idx, idxIps, ip, ips, k, l, len3, len4, len5, m, outport, portIdentifier, results, unforwarded;
          context = result.__bracketContext[inport];
          if (!context.length) {
            return;
          }
          results = [];
          for (outport in result) {
            ips = result[outport];
            if (outport.indexOf('__') === 0) {
              continue;
            }
            if (this.outPorts[outport].isAddressable()) {
              for (idx in ips) {
                idxIps = ips[idx];
                // Don't register indexes we're only sending brackets to
                datas = idxIps.filter(function(ip) {
                  return ip.type === 'data';
                });
                if (!datas.length) {
                  continue;
                }
                portIdentifier = `${outport}[${idx}]`;
                unforwarded = this.getForwardableContexts(inport, portIdentifier, context);
                if (!unforwarded.length) {
                  continue;
                }
                forwardedOpens = [];
                for (k = 0, len3 = unforwarded.length; k < len3; k++) {
                  ctx = unforwarded[k];
                  debugBrackets(`${this.nodeId} openBracket from '${inport}' to '${portIdentifier}': '${ctx.ip.data}'`);
                  ipClone = ctx.ip.clone();
                  ipClone.index = parseInt(idx);
                  forwardedOpens.push(ipClone);
                  ctx.ports.push(portIdentifier);
                  this.getBracketContext('out', outport, ctx.ip.scope, idx).push(ctx);
                }
                forwardedOpens.reverse();
                for (l = 0, len4 = forwardedOpens.length; l < len4; l++) {
                  ip = forwardedOpens[l];
                  this.addToResult(result, outport, ip, true);
                }
              }
              continue;
            }
            // Don't register ports we're only sending brackets to
            datas = ips.filter(function(ip) {
              return ip.type === 'data';
            });
            if (!datas.length) {
              continue;
            }
            unforwarded = this.getForwardableContexts(inport, outport, context);
            if (!unforwarded.length) {
              continue;
            }
            forwardedOpens = [];
            for (m = 0, len5 = unforwarded.length; m < len5; m++) {
              ctx = unforwarded[m];
              debugBrackets(`${this.nodeId} openBracket from '${inport}' to '${outport}': '${ctx.ip.data}'`);
              forwardedOpens.push(ctx.ip.clone());
              ctx.ports.push(outport);
              this.getBracketContext('out', outport, ctx.ip.scope).push(ctx);
            }
            forwardedOpens.reverse();
            results.push((function() {
              var len6, n, results1;
              results1 = [];
              for (n = 0, len6 = forwardedOpens.length; n < len6; n++) {
                ip = forwardedOpens[n];
                results1.push(this.addToResult(result, outport, ip, true));
              }
              return results1;
            }).call(this));
          }
          return results;
        });
      }
      if ((ref3 = result.__bracketClosingAfter) != null ? ref3.length : void 0) {
        ref4 = result.__bracketClosingAfter;
        for (k = 0, len3 = ref4.length; k < len3; k++) {
          context = ref4[k];
          debugBrackets(`${this.nodeId} closeBracket-B from '${context.source}' to ${context.ports}: '${context.closeIp.data}'`);
          if (!context.ports.length) {
            continue;
          }
          ref5 = context.ports;
          for (l = 0, len4 = ref5.length; l < len4; l++) {
            port = ref5[l];
            ipClone = context.closeIp.clone();
            this.addToResult(result, port, ipClone, false);
            this.getBracketContext('out', port, ipClone.scope).pop();
          }
        }
      }
      delete result.__bracketClosingBefore;
      delete result.__bracketContext;
      return delete result.__bracketClosingAfter;
    }

    // Whenever an execution context finishes, send all resolved
    // output from the queue in the order it is in.
    processOutputQueue() {
      var idx, idxIps, ip, ips, port, portIdentifier, result, results;
      results = [];
      while (this.outputQ.length > 0) {
        if (!this.outputQ[0].__resolved) {
          break;
        }
        result = this.outputQ.shift();
        this.addBracketForwards(result);
        results.push((function() {
          var i, len1, results1;
          results1 = [];
          for (port in result) {
            ips = result[port];
            if (port.indexOf('__') === 0) {
              continue;
            }
            if (this.outPorts.ports[port].isAddressable()) {
              for (idx in ips) {
                idxIps = ips[idx];
                idx = parseInt(idx);
                if (!this.outPorts.ports[port].isAttached(idx)) {
                  continue;
                }
                for (i = 0, len1 = idxIps.length; i < len1; i++) {
                  ip = idxIps[i];
                  portIdentifier = `${port}[${ip.index}]`;
                  if (ip.type === 'openBracket') {
                    debugSend(`${this.nodeId} sending ${portIdentifier} < '${ip.data}'`);
                  } else if (ip.type === 'closeBracket') {
                    debugSend(`${this.nodeId} sending ${portIdentifier} > '${ip.data}'`);
                  } else {
                    debugSend(`${this.nodeId} sending ${portIdentifier} DATA`);
                  }
                  if (!this.outPorts[port].options.scoped) {
                    ip.scope = null;
                  }
                  this.outPorts[port].sendIP(ip);
                }
              }
              continue;
            }
            if (!this.outPorts.ports[port].isAttached()) {
              continue;
            }
            results1.push((function() {
              var j, len2, results2;
              results2 = [];
              for (j = 0, len2 = ips.length; j < len2; j++) {
                ip = ips[j];
                portIdentifier = port;
                if (ip.type === 'openBracket') {
                  debugSend(`${this.nodeId} sending ${portIdentifier} < '${ip.data}'`);
                } else if (ip.type === 'closeBracket') {
                  debugSend(`${this.nodeId} sending ${portIdentifier} > '${ip.data}'`);
                } else {
                  debugSend(`${this.nodeId} sending ${portIdentifier} DATA`);
                }
                if (!this.outPorts[port].options.scoped) {
                  ip.scope = null;
                }
                results2.push(this.outPorts[port].sendIP(ip));
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    // Signal that component has activated. There may be multiple
    // activated contexts at the same time
    activate(context) {
      if (context.activated) { // prevent double activation
        return;
      }
      context.activated = true;
      context.deactivated = false;
      this.load++;
      this.emit('activate', this.load);
      if (this.ordered || this.autoOrdering) {
        return this.outputQ.push(context.result);
      }
    }

    // Signal that component has deactivated. There may be multiple
    // activated contexts at the same time
    deactivate(context) {
      if (context.deactivated) { // prevent double deactivation
        return;
      }
      context.deactivated = true;
      context.activated = false;
      if (this.isOrdered()) {
        this.processOutputQueue();
      }
      this.load--;
      return this.emit('deactivate', this.load);
    }

  };

  Component.prototype.description = '';

  Component.prototype.icon = null;

  return Component;

}).call(this);

ProcessContext = class ProcessContext {
  constructor(ip1, nodeInstance, port1, result1) {
    this.ip = ip1;
    this.nodeInstance = nodeInstance;
    this.port = port1;
    this.result = result1;
    this.scope = this.ip.scope;
    this.activated = false;
    this.deactivated = false;
  }

  activate() {
    // Push a new result value if previous has been sent already
    if (this.result.__resolved || this.nodeInstance.outputQ.indexOf(this.result) === -1) {
      this.result = {};
    }
    return this.nodeInstance.activate(this);
  }

  deactivate() {
    if (!this.result.__resolved) {
      this.result.__resolved = true;
    }
    return this.nodeInstance.deactivate(this);
  }

};

ProcessInput = class ProcessInput {
  constructor(ports1, context1) {
    this.ports = ports1;
    this.context = context1;
    this.nodeInstance = this.context.nodeInstance;
    this.ip = this.context.ip;
    this.port = this.context.port;
    this.result = this.context.result;
    this.scope = this.context.scope;
  }

  // When preconditions are met, set component state to `activated`
  activate() {
    if (this.context.activated) {
      return;
    }
    if (this.nodeInstance.isOrdered()) {
      // We're handling packets in order. Set the result as non-resolved
      // so that it can be send when the order comes up
      this.result.__resolved = false;
    }
    this.nodeInstance.activate(this.context);
    if (this.port.isAddressable()) {
      return debug(`${this.nodeInstance.nodeId} packet on '${this.port.name}[${this.ip.index}]' caused activation ${this.nodeInstance.load}: ${this.ip.type}`);
    } else {
      return debug(`${this.nodeInstance.nodeId} packet on '${this.port.name}' caused activation ${this.nodeInstance.load}: ${this.ip.type}`);
    }
  }

  // ## Connection listing
  // This allows components to check which input ports are attached. This is
  // useful mainly for addressable ports
  attached(...args) {
    var i, len1, port, res;
    if (!args.length) {
      args = ['in'];
    }
    res = [];
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      if (!this.ports[port]) {
        throw new Error(`Node ${this.nodeInstance.nodeId} has no port '${port}'`);
      }
      res.push(this.ports[port].listAttached());
    }
    if (args.length === 1) {
      return res.pop();
    }
    return res;
  }

  // ## Input preconditions
  // When the processing function is called, it can check if input buffers
  // contain the packets needed for the process to fire.
  // This precondition handling is done via the `has` and `hasStream` methods.

  // Returns true if a port (or ports joined by logical AND) has a new IP
  // Passing a validation callback as a last argument allows more selective
  // checking of packets.
  has(...args) {
    var i, len1, port, validate;
    if (!args.length) {
      args = ['in'];
    }
    if (typeof args[args.length - 1] === 'function') {
      validate = args.pop();
    } else {
      validate = function() {
        return true;
      };
    }
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      if (Array.isArray(port)) {
        if (!this.ports[port[0]]) {
          throw new Error(`Node ${this.nodeInstance.nodeId} has no port '${port[0]}'`);
        }
        if (!this.ports[port[0]].isAddressable()) {
          throw new Error(`Non-addressable ports, access must be with string ${port[0]}`);
        }
        if (!this.ports[port[0]].has(this.scope, port[1], validate)) {
          return false;
        }
        continue;
      }
      if (!this.ports[port]) {
        throw new Error(`Node ${this.nodeInstance.nodeId} has no port '${port}'`);
      }
      if (this.ports[port].isAddressable()) {
        throw new Error(`For addressable ports, access must be with array [${port}, idx]`);
      }
      if (!this.ports[port].has(this.scope, validate)) {
        return false;
      }
    }
    return true;
  }

  // Returns true if the ports contain data packets
  hasData(...args) {
    if (!args.length) {
      args = ['in'];
    }
    args.push(function(ip) {
      return ip.type === 'data';
    });
    return this.has.apply(this, args);
  }

  // Returns true if a port has a complete stream in its input buffer.
  hasStream(...args) {
    var dataBrackets, hasData, i, len1, port, portBrackets, validate, validateStream;
    if (!args.length) {
      args = ['in'];
    }
    if (typeof args[args.length - 1] === 'function') {
      validateStream = args.pop();
    } else {
      validateStream = function() {
        return true;
      };
    }
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      portBrackets = [];
      dataBrackets = [];
      hasData = false;
      validate = function(ip) {
        if (ip.type === 'openBracket') {
          portBrackets.push(ip.data);
          return false;
        }
        if (ip.type === 'data') {
          // Run the stream validation callback
          hasData = validateStream(ip, portBrackets);
          if (!portBrackets.length) {
            // Data IP on its own is a valid stream
            return hasData;
          }
          // Otherwise we need to check for complete stream
          return false;
        }
        if (ip.type === 'closeBracket') {
          portBrackets.pop();
          if (portBrackets.length) {
            return false;
          }
          if (!hasData) {
            return false;
          }
          return true;
        }
      };
      if (!this.has(port, validate)) {
        return false;
      }
    }
    return true;
  }

  // ## Input processing

  // Once preconditions have been met, the processing function can read from
  // the input buffers. Reading packets sets the component as "activated".

  // Fetches IP object(s) for port(s)
  get(...args) {
    var i, idx, ip, len1, port, portname, res;
    this.activate();
    if (!args.length) {
      args = ['in'];
    }
    res = [];
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      if (Array.isArray(port)) {
        [portname, idx] = port;
        if (!this.ports[portname].isAddressable()) {
          throw new Error('Non-addressable ports, access must be with string portname');
        }
      } else {
        portname = port;
        if (this.ports[portname].isAddressable()) {
          throw new Error('For addressable ports, access must be with array [portname, idx]');
        }
      }
      if (this.nodeInstance.isForwardingInport(portname)) {
        ip = this.__getForForwarding(portname, idx);
        res.push(ip);
        continue;
      }
      ip = this.ports[portname].get(this.scope, idx);
      res.push(ip);
    }
    if (args.length === 1) {
      return res[0];
    } else {
      return res;
    }
  }

  __getForForwarding(port, idx) {
    var context, dataIp, i, ip, len1, prefix;
    prefix = [];
    dataIp = null;
    while (true) {
      // Read next packet
      // Read IPs until we hit data
      ip = this.ports[port].get(this.scope, idx);
      if (!ip) {
        // Stop at the end of the buffer
        break;
      }
      if (ip.type === 'data') {
        // Hit the data IP, stop here
        dataIp = ip;
        break;
      }
      // Keep track of bracket closings and openings before
      prefix.push(ip);
    }
// Forwarding brackets that came before data packet need to manipulate context
// and be added to result so they can be forwarded correctly to ports that
// need them
    for (i = 0, len1 = prefix.length; i < len1; i++) {
      ip = prefix[i];
      if (ip.type === 'closeBracket') {
        if (!this.result.__bracketClosingBefore) {
          // Bracket closings before data should remove bracket context
          this.result.__bracketClosingBefore = [];
        }
        context = this.nodeInstance.getBracketContext('in', port, this.scope, idx).pop();
        context.closeIp = ip;
        this.result.__bracketClosingBefore.push(context);
        continue;
      }
      if (ip.type === 'openBracket') {
        // Bracket openings need to go to bracket context
        this.nodeInstance.getBracketContext('in', port, this.scope, idx).push({
          ip: ip,
          ports: [],
          source: port
        });
        continue;
      }
    }
    if (!this.result.__bracketContext) {
      // Add current bracket context to the result so that when we send
      // to ports we can also add the surrounding brackets
      this.result.__bracketContext = {};
    }
    this.result.__bracketContext[port] = this.nodeInstance.getBracketContext('in', port, this.scope, idx).slice(0);
    // Bracket closings that were in buffer after the data packet need to
    // be added to result for done() to read them from
    return dataIp;
  }

  // Fetches `data` property of IP object(s) for given port(s)
  getData(...args) {
    var datas, i, len1, packet, port;
    if (!args.length) {
      args = ['in'];
    }
    datas = [];
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      packet = this.get(port);
      if (packet == null) {
        // we add the null packet to the array so when getting
        // multiple ports, if one is null we still return it
        // so the indexes are correct.
        datas.push(packet);
        continue;
      }
      while (packet.type !== 'data') {
        packet = this.get(port);
        if (!packet) {
          break;
        }
      }
      datas.push(packet.data);
    }
    if (args.length === 1) {
      return datas.pop();
    }
    return datas;
  }

  // Fetches a complete data stream from the buffer.
  getStream(...args) {
    var datas, hasData, i, ip, len1, port, portBrackets, portPackets;
    if (!args.length) {
      args = ['in'];
    }
    datas = [];
    for (i = 0, len1 = args.length; i < len1; i++) {
      port = args[i];
      portBrackets = [];
      portPackets = [];
      hasData = false;
      ip = this.get(port);
      if (!ip) {
        datas.push(void 0);
      }
      while (ip) {
        if (ip.type === 'openBracket') {
          if (!portBrackets.length) {
            // First openBracket in stream, drop previous
            portPackets = [];
            hasData = false;
          }
          portBrackets.push(ip.data);
          portPackets.push(ip);
        }
        if (ip.type === 'data') {
          portPackets.push(ip);
          hasData = true;
          if (!portBrackets.length) {
            // Unbracketed data packet is a valid stream
            break;
          }
        }
        if (ip.type === 'closeBracket') {
          portPackets.push(ip);
          portBrackets.pop();
          if (hasData && !portBrackets.length) {
            // Last close bracket finishes stream if there was data inside
            break;
          }
        }
        ip = this.get(port);
      }
      datas.push(portPackets);
    }
    if (args.length === 1) {
      return datas.pop();
    }
    return datas;
  }

};

ProcessOutput = class ProcessOutput {
  constructor(ports1, context1) {
    this.ports = ports1;
    this.context = context1;
    this.nodeInstance = this.context.nodeInstance;
    this.ip = this.context.ip;
    this.result = this.context.result;
    this.scope = this.context.scope;
  }

  // Checks if a value is an Error
  isError(err) {
    return err instanceof Error || Array.isArray(err) && err.length > 0 && err[0] instanceof Error;
  }

  // Sends an error object
  error(err) {
    var e, i, j, len1, len2, multiple, results;
    multiple = Array.isArray(err);
    if (!multiple) {
      err = [err];
    }
    if ('error' in this.ports && (this.ports.error.isAttached() || !this.ports.error.isRequired())) {
      if (multiple) {
        this.sendIP('error', new IP('openBracket'));
      }
      for (i = 0, len1 = err.length; i < len1; i++) {
        e = err[i];
        this.sendIP('error', e);
      }
      if (multiple) {
        return this.sendIP('error', new IP('closeBracket'));
      }
    } else {
      results = [];
      for (j = 0, len2 = err.length; j < len2; j++) {
        e = err[j];
        throw e;
      }
      return results;
    }
  }

  // Sends a single IP object to a port
  sendIP(port, packet) {
    var ip;
    if (!IP.isIP(packet)) {
      ip = new IP('data', packet);
    } else {
      ip = packet;
    }
    if (this.scope !== null && ip.scope === null) {
      ip.scope = this.scope;
    }
    if (this.nodeInstance.outPorts[port].isAddressable() && ip.index === null) {
      throw new Error('Sending packets to addressable ports requires specifying index');
    }
    if (this.nodeInstance.isOrdered()) {
      this.nodeInstance.addToResult(this.result, port, ip);
      return;
    }
    if (!this.nodeInstance.outPorts[port].options.scoped) {
      ip.scope = null;
    }
    return this.nodeInstance.outPorts[port].sendIP(ip);
  }

  // Sends packets for each port as a key in the map
  // or sends Error or a list of Errors if passed such
  send(outputMap) {
    var componentPorts, i, len1, mapIsInPorts, packet, port, ref, results;
    if (this.isError(outputMap)) {
      return this.error(outputMap);
    }
    componentPorts = [];
    mapIsInPorts = false;
    ref = Object.keys(this.ports.ports);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      port = ref[i];
      if (port !== 'error' && port !== 'ports' && port !== '_callbacks') {
        componentPorts.push(port);
      }
      if (!mapIsInPorts && (outputMap != null) && typeof outputMap === 'object' && Object.keys(outputMap).indexOf(port) !== -1) {
        mapIsInPorts = true;
      }
    }
    if (componentPorts.length === 1 && !mapIsInPorts) {
      this.sendIP(componentPorts[0], outputMap);
      return;
    }
    if (componentPorts.length > 1 && !mapIsInPorts) {
      throw new Error('Port must be specified for sending output');
    }
    results = [];
    for (port in outputMap) {
      packet = outputMap[port];
      results.push(this.sendIP(port, packet));
    }
    return results;
  }

  // Sends the argument via `send()` and marks activation as `done()`
  sendDone(outputMap) {
    this.send(outputMap);
    return this.done();
  }

  // Makes a map-style component pass a result value to `out`
  // keeping all IP metadata received from `in`,
  // or modifying it if `options` is provided
  pass(data, options = {}) {
    var key, val;
    if (!('out' in this.ports)) {
      throw new Error('output.pass() requires port "out" to be present');
    }
    for (key in options) {
      val = options[key];
      this.ip[key] = val;
    }
    this.ip.data = data;
    this.sendIP('out', this.ip);
    return this.done();
  }

  // Finishes process activation gracefully
  done(error) {
    var buf, context, contexts, ctx, ip, isLast, nodeContext, port, ref;
    this.result.__resolved = true;
    this.nodeInstance.activate(this.context);
    if (error) {
      this.error(error);
    }
    isLast = () => {
      var len, load, pos, resultsOnly;
      // We only care about real output sets with processing data
      resultsOnly = this.nodeInstance.outputQ.filter(function(q) {
        if (!q.__resolved) {
          return true;
        }
        if (Object.keys(q).length === 2 && q.__bracketClosingAfter) {
          return false;
        }
        return true;
      });
      pos = resultsOnly.indexOf(this.result);
      len = resultsOnly.length;
      load = this.nodeInstance.load;
      if (pos === len - 1) {
        return true;
      }
      if (pos === -1 && load === len + 1) {
        return true;
      }
      if (len <= 1 && load === 1) {
        return true;
      }
      return false;
    };
    if (this.nodeInstance.isOrdered() && isLast()) {
      ref = this.nodeInstance.bracketContext.in;
      // We're doing bracket forwarding. See if there are
      // dangling closeBrackets in buffer since we're the
      // last running process function.
      for (port in ref) {
        contexts = ref[port];
        if (!contexts[this.scope]) {
          continue;
        }
        nodeContext = contexts[this.scope];
        if (!nodeContext.length) {
          continue;
        }
        context = nodeContext[nodeContext.length - 1];
        buf = this.nodeInstance.inPorts[context.source].getBuffer(context.ip.scope, context.ip.index);
        while (true) {
          if (!buf.length) {
            break;
          }
          if (buf[0].type !== 'closeBracket') {
            break;
          }
          ip = this.nodeInstance.inPorts[context.source].get(context.ip.scope, context.ip.index);
          ctx = nodeContext.pop();
          ctx.closeIp = ip;
          if (!this.result.__bracketClosingAfter) {
            this.result.__bracketClosingAfter = [];
          }
          this.result.__bracketClosingAfter.push(ctx);
        }
      }
    }
    debug(`${this.nodeInstance.nodeId} finished processing ${this.nodeInstance.load}`);
    return this.nodeInstance.deactivate(this.context);
  }

};

exports.Component = Component;
