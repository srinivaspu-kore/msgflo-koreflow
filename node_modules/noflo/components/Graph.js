//     NoFlo - Flow-Based Programming for JavaScript
//     (c) 2013-2017 Flowhub UG
//     (c) 2011-2012 Henri Bergius, Nemein
//     NoFlo may be freely distributed under the MIT license

// The Graph component is used to wrap NoFlo Networks into components inside
// another network.
var Graph, noflo;

noflo = require("../lib/NoFlo");

Graph = class Graph extends noflo.Component {
  constructor(metadata) {
    super();
    this.metadata = metadata;
    this.network = null;
    this.ready = true;
    this.started = false;
    this.starting = false;
    this.baseDir = null;
    this.loader = null;
    this.load = 0;
    this.inPorts = new noflo.InPorts({
      graph: {
        datatype: 'all',
        description: 'NoFlo graph definition to be used with the subgraph component',
        required: true
      }
    });
    this.outPorts = new noflo.OutPorts;
    this.inPorts.graph.on('ip', (packet) => {
      if (packet.type !== 'data') {
        return;
      }
      return this.setGraph(packet.data, (err) => {
        if (err) {
          // TODO: Port this part to Process API and use output.error method instead
          return this.error(err);
        }
      });
    });
  }

  setGraph(graph, callback) {
    this.ready = false;
    if (typeof graph === 'object') {
      if (typeof graph.addNode === 'function') {
        // Existing Graph object
        this.createNetwork(graph, callback);
        return;
      }
      // JSON definition of a graph
      noflo.graph.loadJSON(graph, (err, instance) => {
        if (err) {
          return callback(err);
        }
        instance.baseDir = this.baseDir;
        return this.createNetwork(instance, callback);
      });
      return;
    }
    if (graph.substr(0, 1) !== "/" && graph.substr(1, 1) !== ":" && process && process.cwd) {
      graph = `${process.cwd()}/${graph}`;
    }
    return noflo.graph.loadFile(graph, (err, instance) => {
      if (err) {
        return callback(err);
      }
      instance.baseDir = this.baseDir;
      return this.createNetwork(instance, callback);
    });
  }

  createNetwork(graph, callback) {
    this.description = graph.properties.description || '';
    this.icon = graph.properties.icon || this.icon;
    if (!graph.name) {
      graph.name = this.nodeId;
    }
    graph.componentLoader = this.loader;
    return noflo.createNetwork(graph, (err, network1) => {
      this.network = network1;
      if (err) {
        return callback(err);
      }
      this.emit('network', this.network);
      // Subscribe to network lifecycle
      this.subscribeNetwork(this.network);
      // Wire the network up
      return this.network.connect((err) => {
        var name, node, ref;
        if (err) {
          return callback(err);
        }
        ref = this.network.processes;
        for (name in ref) {
          node = ref[name];
          // Map exported ports to local component
          this.findEdgePorts(name, node);
        }
        // Finally set ourselves as "ready"
        this.setToReady();
        return callback();
      });
    }, true);
  }

  subscribeNetwork(network) {
    var contexts;
    contexts = [];
    this.network.on('start', () => {
      var ctx;
      ctx = {};
      contexts.push(ctx);
      return this.activate(ctx);
    });
    return this.network.on('end', () => {
      var ctx;
      ctx = contexts.pop();
      if (!ctx) {
        return;
      }
      return this.deactivate(ctx);
    });
  }

  isExportedInport(port, nodeName, portName) {
    var priv, pub, ref;
    ref = this.network.graph.inports;
    // First we check disambiguated exported ports
    for (pub in ref) {
      priv = ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    // Component has exported ports and this isn't one of them
    return false;
  }

  isExportedOutport(port, nodeName, portName) {
    var priv, pub, ref;
    ref = this.network.graph.outports;
    // First we check disambiguated exported ports
    for (pub in ref) {
      priv = ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    // Component has exported ports and this isn't one of them
    return false;
  }

  setToReady() {
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick(() => {
        this.ready = true;
        return this.emit('ready');
      });
    } else {
      return setTimeout(() => {
        this.ready = true;
        return this.emit('ready');
      }, 0);
    }
  }

  findEdgePorts(name, process) {
    var inPorts, outPorts, port, portName, targetPortName;
    inPorts = process.component.inPorts.ports;
    outPorts = process.component.outPorts.ports;
    for (portName in inPorts) {
      port = inPorts[portName];
      targetPortName = this.isExportedInport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.inPorts.add(targetPortName, port);
      this.inPorts[targetPortName].on('connect', () => {
        // Start the network implicitly if we're starting to get data
        if (this.starting) {
          return;
        }
        if (this.network.isStarted()) {
          return;
        }
        if (this.network.startupDate) {
          // Network was started, but did finish. Re-start simply
          this.network.setStarted(true);
          return;
        }
        // Network was never started, start properly
        return this.setUp(function() {});
      });
    }
    for (portName in outPorts) {
      port = outPorts[portName];
      targetPortName = this.isExportedOutport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.outPorts.add(targetPortName, port);
    }
    return true;
  }

  isReady() {
    return this.ready;
  }

  isSubgraph() {
    return true;
  }

  isLegacy() {
    return false;
  }

  setUp(callback) {
    this.starting = true;
    if (!this.isReady()) {
      this.once('ready', () => {
        return this.setUp(callback);
      });
      return;
    }
    if (!this.network) {
      return callback(null);
    }
    return this.network.start((err) => {
      if (err) {
        return callback(err);
      }
      this.starting = false;
      return callback();
    });
  }

  tearDown(callback) {
    this.starting = false;
    if (!this.network) {
      return callback(null);
    }
    return this.network.stop(function(err) {
      if (err) {
        return callback(err);
      }
      return callback();
    });
  }

};

exports.getComponent = function(metadata) {
  return new Graph(metadata);
};
