var TraceBuffer, Tracer, clone, debug, e, jsonStringify, networkToTraceEvent, noflo, subscribeExportedOutports;

noflo = require('noflo');

debug = require('debug')('noflo-runtime-base:trace');

jsonStringify = JSON.stringify;

try {
  jsonStringify = require('json-stringify-safe');
} catch (error) {
  e = error;
  console.log(`WARN: failed to load json-stringify-safe, circular objects may cause fail.\n${e.message}`);
}

clone = function(obj) {
  var s;
  s = jsonStringify(obj);
  return JSON.parse(s);
};

TraceBuffer = class TraceBuffer {
  constructor() {
    this.events = []; // PERF: use a linked-list variety instead
  }

  add(event) {
    // FIXME: respect a (configurable) limit on size https://github.com/noflo/noflo-runtime-base/issues/34
    return this.events.push(event);
  }

  getAll(consumeFunc, doneFunc) {
    var i, len, ref;
    ref = this.events;
    for (i = 0, len = ref.length; i < len; i++) {
      e = ref[i];
      consumeFunc(e);
    }
    return doneFunc(null);
  }

};

subscribeExportedOutports = function(network, networkId, eventNames, subscribeFunc) {
  var component, event, graphSockets, i, internal, len, pub, ref, sendFunc, socket;
  graphSockets = {};
  ref = network.graph.outports;
  // Basically same as code in runtime:data protocol handling
  for (pub in ref) {
    internal = ref[pub];
    socket = noflo.internalSocket.createSocket();
    graphSockets[pub] = socket;
    component = network.processes[internal.process].component;
    component.outPorts[internal.port].attach(socket);
    sendFunc = function(event) {
      return function(payload) {
        var data;
        data = {
          id: `EXPORT: ${networkId} ${pub.toUpperCase()
          // just for debugging
} ->`,
          payload: payload,
          socket: {
            to: {
              process: {
                id: networkId
              },
              port: pub
            }
          }
        };
        return subscribeFunc(event, data);
      };
    };
    for (i = 0, len = eventNames.length; i < len; i++) {
      event = eventNames[i];
      socket.on(event, sendFunc(event));
    }
  }
  return graphSockets;
};

// Convert to flowtrace/FBP-protocol format http://noflojs.org/documentation/protocol/
networkToTraceEvent = function(networkId, type, data) {
  var event, p, ref, ref1, ref2, ref3, serializeGroup, socket;
  debug('event', networkId, type, `'${data.id}'`);
  socket = data.socket;
  // XXX: wasteful to have the network thing in each event?
  event = {
    protocol: 'network',
    command: type,
    payload: {
      time: new Date().toISOString(),
      graph: networkId,
      error: null, // used to indicate tracing errors
      src: {
        node: (ref = socket.from) != null ? ref.process.id : void 0,
        port: (ref1 = socket.from) != null ? ref1.port : void 0
      },
      tgt: {
        node: (ref2 = socket.to) != null ? ref2.process.id : void 0,
        port: (ref3 = socket.to) != null ? ref3.port : void 0
      },
      id: void 0, // deprecated
      subgraph: void 0 // TODO: implement
    }
  };
  serializeGroup = function(p) {
    try {
      return p.group = data.group.toString();
    } catch (error) {
      e = error;
      debug('group serialization error', e);
      return p.error = e.message;
    }
  };
  p = event.payload;
  switch (type) {
    case 'connect':
      null;
      break;
    case 'disconnect':
      null;
      break;
    case 'begingroup':
      serializeGroup(event.payload);
      break;
    case 'endgroup':
      serializeGroup(event.payload);
      break;
    case 'data':
      try {
        p.data = clone(data.data);
      } catch (error) {
        e = error;
        debug('data serialization error', e);
        p.error = e.message;
      }
      break;
    default:
      throw new Error(`trace: Unknown event type ${type}`);
  }
  debug('event done', networkId, type, `'${data.id}'`);
  return event;
};

// Can be attached() to a NoFlo network, and keeps a circular buffer of events
// which can be persisted on request
Tracer = class Tracer {
  constructor(options) {
    this.options = options;
    this.buffer = new TraceBuffer;
    this.header = {
      graphs: {}
    };
  }

  attach(network) {
    var eventNames, netId, sockets;
    // FIXME: graphs loaded from .fbp don't have name. Should default to basename of file, and be configurable
    netId = network.graph.name || network.graph.properties.name || 'default';
    debug('attach', netId);
    eventNames = ['connect', 'begingroup', 'data', 'endgroup', 'disconnect'];
    // internal network events
    eventNames.forEach((event) => {
      return network.on(event, (data) => {
        var payload;
        payload = networkToTraceEvent(netId, event, data);
        return this.buffer.add(payload);
      });
    });
    // exported outport
    sockets = subscribeExportedOutports(network, netId, eventNames, (event, data) => {
      var payload;
      payload = networkToTraceEvent(netId, event, data);
      return this.buffer.add(payload);
    });
    return this.header.graphs[netId] = network.graph.toJSON();
  }

  detach(network) {}

  // Serialize current content of buffer
  // TODO: implement
  dumpString(callback) {
    var consume, events;
    events = [];
    consume = function(e) {
      return events.push(e);
    };
    return this.buffer.getAll(consume, (err) => {
      var trace;
      trace = {
        header: this.header,
        events: events
      };
      return callback(err, JSON.stringify(trace, null, 2));
    });
  }

  // node.js only
  dumpFile(filepath, callback) {
    var fs, openFile, temp;
    fs = require('fs');
    temp = require('temp');
    openFile = function(cb) {
      return fs.open(filepath, 'w', function(err, fd) {
        return cb(err, {
          path: filepath,
          fd: fd
        });
      });
    };
    if (!filepath) {
      openFile = function(cb) {
        return temp.open({
          suffix: '.json'
        }, cb);
      };
    }
    return openFile((err, info) => {
      var events, header, write, writeEvent;
      if (err) {
        return callback(err);
      }
      // HACKY json streaming serialization
      events = 0;
      write = function(data, cb) {
        return fs.write(info.fd, data, {
          encoding: 'utf-8'
        }, cb);
      };
      writeEvent = function(e) {
        var s;
        s = events ? ',' : '';
        events += 1;
        s += JSON.stringify(e, null, 2);
        return write(s, function(err) {});
      };
      // FIXME: handle, wait
      debug('streaming to file', info.path);
      header = JSON.stringify(this.header, null, 2);
      return write(`{\n "header": ${header}\n, "events":\n[`, (err) => {
        return this.buffer.getAll(writeEvent, function(err) {
          if (err) {
            return callback(err);
          }
          debug(`streamed ${events} events`);
          return write(']\n }', function(err) {
            debug("completed stream", info.path);
            return callback(err, info.path);
          });
        });
      });
    });
  }

};

module.exports.Tracer = Tracer;
