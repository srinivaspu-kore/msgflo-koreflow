var ComponentProtocol, EventEmitter, debounce, noflo, utils;

noflo = require('noflo');

debounce = require('debounce');

EventEmitter = require('events').EventEmitter;

utils = require('../utils');

ComponentProtocol = (function() {
  class ComponentProtocol extends EventEmitter {
    constructor(transport) {
      super();
      this.transport = transport;
    }

    send(topic, payload, context) {
      return this.transport.send('component', topic, payload, context);
    }

    receive(topic, payload, context) {
      switch (topic) {
        case 'list':
          return this.listComponents(payload, context);
        case 'getsource':
          return this.getSource(payload, context);
        case 'source':
          return this.setSource(payload, context);
        default:
          return this.send('error', new Error(`component:${topic} not supported`), context);
      }
    }

    getLoader(baseDir, options = {}) {
      if (!this.loaders[baseDir]) {
        this.loaders[baseDir] = new noflo.ComponentLoader(baseDir, options);
      }
      return this.loaders[baseDir];
    }

    listComponents(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.listComponents((err, components) => {
        var componentNames, processed;
        if (err) {
          this.send('error', err, context);
          return;
        }
        componentNames = Object.keys(components);
        processed = 0;
        return componentNames.forEach((component) => {
          return this.processComponent(loader, component, context, (err) => {
            processed++;
            if (processed < componentNames.length) {
              return;
            }
            return this.send('componentsready', processed, context);
          });
        });
      });
    }

    getSource(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.getSource(payload.name, (err, component) => {
        var graph, nameParts;
        if (err) {
          // Try one of the registered graphs
          graph = this.transport.graph.graphs[payload.name];
          if (graph == null) {
            this.send('error', err, context);
            return;
          }
          nameParts = utils.parseName(payload.name);
          return this.send('source', {
            name: nameParts.name,
            library: nameParts.library,
            code: JSON.stringify(graph.toJSON()),
            language: 'json'
          }, context);
        } else {
          return this.send('source', component, context);
        }
      });
    }

    setSource(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir, this.transport.options);
      return loader.setSource(payload.library, payload.name, payload.code, payload.language, (err) => {
        if (err) {
          this.send('error', err, context);
          return;
        }
        this.emit('updated', {
          name: payload.name,
          library: payload.library,
          code: payload.code,
          language: payload.language
        });
        return this.processComponent(loader, loader.normalizeName(payload.library, payload.name), context);
      });
    }

    processComponent(loader, component, context, callback) {
      if (!callback) {
        callback = function() {};
      }
      return loader.load(component, (err, instance) => {
        if (!instance) {
          if (err instanceof Error) {
            this.send('error', err, context);
            return callback(err);
          }
          instance = err;
        }
        // Ensure graphs are not run automatically when just querying their ports
        if (!instance.isReady()) {
          instance.once('ready', () => {
            this.sendComponent(component, instance, context);
            return callback(null);
          });
          return;
        }
        this.sendComponent(component, instance, context);
        return callback(null);
      }, true);
    }

    processPort(portName, port) {
      var portDef, ref;
      // Required port properties
      portDef = {
        id: portName,
        type: port.getDataType ? port.getDataType() : 'all'
      };
      if (typeof port.getSchema === "function" ? port.getSchema() : void 0) {
        portDef.schema = port.getSchema();
      }
      if (port.isRequired) {
        portDef.required = port.isRequired();
      }
      if (port.isAddressable) {
        portDef.addressable = port.isAddressable();
      }
      if (port.getDescription) {
        portDef.description = port.getDescription();
      }
      if ((ref = port.options) != null ? ref.values : void 0) {
        portDef.values = port.options.values;
      }
      if (typeof port.hasDefault === "function" ? port.hasDefault() : void 0) {
        portDef.default = port.options.default;
      }
      return portDef;
    }

    sendComponent(component, instance, context) {
      var icon, inPorts, outPorts, port, portName, ref, ref1;
      inPorts = [];
      outPorts = [];
      ref = instance.inPorts;
      for (portName in ref) {
        port = ref[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        inPorts.push(this.processPort(portName, port));
      }
      ref1 = instance.outPorts;
      for (portName in ref1) {
        port = ref1[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        outPorts.push(this.processPort(portName, port));
      }
      icon = instance.getIcon ? instance.getIcon() : 'gear';
      return this.send('component', {
        name: component,
        description: instance.description,
        subgraph: instance.isSubgraph(),
        icon: icon,
        inPorts: inPorts,
        outPorts: outPorts
      }, context);
    }

    registerGraph(id, graph, context) {
      var loader, send, sender;
      sender = () => {
        return this.processComponent(loader, id, context);
      };
      send = debounce(sender, 10);
      loader = this.getLoader(graph.baseDir, this.transport.options);
      loader.listComponents((err, components) => {
        if (err) {
          this.send('error', err, context);
          return;
        }
        loader.registerComponent('', id, graph);
        // Send initial graph info back to client
        return send();
      });
      // Send graph info again every time it changes so we get the updated ports
      graph.on('addNode', send);
      graph.on('removeNode', send);
      graph.on('renameNode', send);
      graph.on('addEdge', send);
      graph.on('removeEdge', send);
      graph.on('addInitial', send);
      graph.on('removeInitial', send);
      graph.on('addInport', send);
      graph.on('removeInport', send);
      graph.on('renameInport', send);
      graph.on('addOutport', send);
      graph.on('removeOutport', send);
      return graph.on('renameOutport', send);
    }

  };

  ComponentProtocol.prototype.loaders = {};

  return ComponentProtocol;

}).call(this);

module.exports = ComponentProtocol;
