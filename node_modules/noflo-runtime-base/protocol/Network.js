var EventEmitter, NetworkProtocol, getConnectionSignature, getEdgeSignature, getPortSignature, getSocketSignature, noflo, prepareSocketEvent;

noflo = require('noflo');

EventEmitter = require('events').EventEmitter;

prepareSocketEvent = function(event, graphName) {
  var payload, ref, ref1, ref2;
  payload = {
    id: event.id,
    graph: graphName
  };
  if (event.socket.from) {
    payload.src = {
      node: event.socket.from.process.id,
      port: event.socket.from.port
    };
  }
  if (event.socket.to) {
    payload.tgt = {
      node: event.socket.to.process.id,
      port: event.socket.to.port
    };
  }
  if (event.subgraph) {
    payload.subgraph = event.subgraph;
  }
  if (typeof event.group !== 'undefined') {
    payload.group = event.group;
  }
  if (event.datatype) {
    payload.type = event.datatype;
  }
  if (event.schema) {
    payload.schema = event.schema;
  }
  if (typeof event.data !== 'undefined') {
    if (!noflo.isBrowser()) {
      if (Buffer.isBuffer(event.data)) {
        // Make sure we're not trying to serialize the whole buffer to JSON
        event.data = event.data.slice(0, 20);
      }
    }
    if ((ref = event.data) != null ? ref.toJSON : void 0) {
      payload.data = event.data.toJSON();
    }
    if ((ref1 = event.data) != null ? ref1.toString : void 0) {
      payload.data = event.data.toString();
      if (payload.data === '[object Object]') {
        try {
          payload.data = JSON.parse(JSON.stringify(event.data));
        } catch (error1) {}
      }
    } else {
      payload.data = event.data;
    }
    if ((ref2 = event.metadata) != null ? ref2.secure : void 0) {
      // Don't send actual payload for private connections
      payload.data = 'DATA';
    }
  }
  return payload;
};

getPortSignature = function(item) {
  if (!item) {
    return '';
  }
  return item.process + '(' + item.port + ')';
};

getEdgeSignature = function(edge) {
  return getPortSignature(edge.src) + ' -> ' + getPortSignature(edge.tgt);
};

getConnectionSignature = function(connection) {
  if (!connection) {
    return '';
  }
  return connection.process.id + '(' + connection.port + ')';
};

getSocketSignature = function(socket) {
  return getConnectionSignature(socket.from) + ' -> ' + getConnectionSignature(socket.to);
};

NetworkProtocol = class NetworkProtocol extends EventEmitter {
  constructor(transport) {
    super();
    this.transport = transport;
    this.networks = {};
  }

  send(topic, payload, context) {
    return this.transport.send('network', topic, payload, context);
  }

  sendAll(topic, payload) {
    return this.transport.sendAll('network', topic, payload);
  }

  receive(topic, payload, context) {
    var graph;
    graph = this.resolveGraph(payload, context);
    if (!graph) {
      return;
    }
    switch (topic) {
      case 'start':
        return this.startNetwork(graph, payload, context);
      case 'stop':
        return this.stopNetwork(graph, payload, context);
      case 'edges':
        return this.updateEdgesFilter(graph, payload, context);
      case 'debug':
        return this.debugNetwork(graph, payload, context);
      case 'getstatus':
        return this.getStatus(graph, payload, context);
      default:
        return this.send('error', new Error(`network:${topic} not supported`), context);
    }
  }

  resolveGraph(payload, context) {
    if (!payload.graph) {
      this.send('error', new Error('No graph specified'), context);
      return;
    }
    if (!this.transport.graph.graphs[payload.graph]) {
      this.send('error', new Error('Requested graph not found'), context);
      return;
    }
    return this.transport.graph.graphs[payload.graph];
  }

  updateEdgesFilter(graph, payload, context) {
    var edge, j, len, network, ref, signature;
    network = this.networks[payload.graph];
    if (network) {
      network.filters = {};
    } else {
      network = {
        network: null,
        filters: {}
      };
      this.networks[payload.graph] = network;
    }
    ref = payload.edges;
    for (j = 0, len = ref.length; j < len; j++) {
      edge = ref[j];
      signature = getEdgeSignature(edge);
      network.filters[signature] = true;
    }
    return this.send('edges', {
      graph: payload.graph,
      edges: payload.edges
    }, context);
  }

  eventFiltered(graph, event) {
    var sign;
    if (!this.transport.options.filterData) {
      return true;
    }
    sign = getSocketSignature(event.socket);
    return this.networks[graph].filters[sign];
  }

  initNetwork(graph, graphName, context, callback) {
    var network, opts;
    // Ensure we stop previous network
    if (this.networks[graphName] && this.networks[graphName].network) {
      network = this.networks[graphName].network;
      network.stop((err) => {
        if (err) {
          return callback(err);
        }
        delete this.networks[graphName];
        this.emit('removenetwork', network, graphName, this.networks);
        return this.initNetwork(graph, graphName, context, callback);
      });
      return;
    }
    graph.componentLoader = this.transport.component.getLoader(graph.baseDir, this.transport.options);
    opts = JSON.parse(JSON.stringify(this.transport.options));
    opts.delay = true;
    return noflo.createNetwork(graph, (err, network) => {
      if (err) {
        return callback(err);
      }
      if (this.networks[graphName] && this.networks[graphName].network) {
        this.networks[graphName].network = network;
      } else {
        this.networks[graphName] = {
          network: network,
          filters: {}
        };
      }
      this.emit('addnetwork', network, graphName, this.networks);
      this.subscribeNetwork(network, graphName, context);
      // Run the network
      return network.connect(callback);
    }, opts);
  }

  subscribeNetwork(network, graphName, context) {
    network.on('start', (event) => {
      return this.sendAll('started', {
        time: event.start,
        graph: graphName,
        running: network.isRunning(),
        started: network.isStarted()
      }, context);
    });
    network.on('end', (event) => {
      return this.sendAll('stopped', {
        time: new Date,
        uptime: event.uptime,
        graph: graphName,
        running: network.isRunning(),
        started: network.isStarted()
      }, context);
    });
    network.on('icon', (event) => {
      event.graph = graphName;
      return this.sendAll('icon', event, context);
    });
    network.on('ip', (event) => {
      var protocolEvent;
      if (!this.eventFiltered(graphName, event)) {
        return;
      }
      protocolEvent = {
        id: event.id,
        socket: event.socket,
        subgraph: event.subgraph,
        metadata: event.metadata
      };
      switch (event.type) {
        case 'openBracket':
          protocolEvent.type = 'begingroup';
          protocolEvent.group = event.data || '';
          break;
        case 'data':
          protocolEvent.type = 'data';
          protocolEvent.data = event.data;
          protocolEvent.datatype = event.datatype;
          protocolEvent.schema = event.schema;
          break;
        case 'closeBracket':
          protocolEvent.type = 'endgroup';
          protocolEvent.group = event.data || '';
      }
      return this.sendAll(protocolEvent.type, prepareSocketEvent(protocolEvent, graphName), context);
    });
    return network.on('process-error', (event) => {
      var bt, error, i, j, ref;
      error = event.error.message;
      // If we can get a backtrace, send 3 levels
      if (event.error.stack) {
        bt = event.error.stack.split('\n');
        for (i = j = 0, ref = Math.min(bt.length, 3); (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          error += `\n${bt[i]}`;
        }
      }
      return this.sendAll('processerror', {
        id: event.id,
        error: error,
        graph: graphName
      }, context);
    });
  }

  _startNetwork(graph, graphName, context, callback) {
    var doStart, network;
    doStart = function(net) {
      return net.start(function(err) {
        return callback(err);
      });
    };
    network = this.networks[graphName];
    if (network && network.network) {
      // already initialized
      return doStart(network.network);
    }
    return this.initNetwork(graph, graphName, context, (err) => {
      if (err) {
        return callback(err);
      }
      network = this.networks[graphName];
      return doStart(network.network);
    });
  }

  startNetwork(graph, payload, context) {
    var network;
    network = this.networks[payload.graph];
    return this._startNetwork(graph, payload.graph, context, (err) => {
      if (err) {
        this.send('error', err, context);
      }
    });
  }

  stopNetwork(graph, payload, context) {
    var net;
    if (!this.networks[payload.graph]) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    net = this.networks[payload.graph].network;
    if (!net) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    if (net.isStarted()) {
      this.networks[payload.graph].network.stop((err) => {
        if (err) {
          this.send('error', err, context);
          return;
        }
        this.send('stopped', {
          time: new Date,
          graph: payload.graph,
          running: net.isRunning(),
          started: net.isStarted()
        }, context);
      });
      return;
    }
    // Was already stopped, just send the confirmation
    return this.send('stopped', {
      time: new Date,
      graph: payload.graph,
      running: net.isRunning(),
      started: net.isStarted()
    }, context);
  }

  debugNetwork(graph, payload, context) {
    var net;
    if (!this.networks[payload.graph]) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    net = this.networks[payload.graph].network;
    if (!net) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    net.setDebug(payload.enable);
    this.send('setdebug', {
      enable: payload.enable
    });
  }

  getStatus(graph, payload, context) {
    var net;
    if (!this.networks[payload.graph]) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    net = this.networks[payload.graph].network;
    if (!net) {
      this.send('error', new Error(`Network ${payload.graph} not found`), context);
      return;
    }
    return this.send('status', {
      graph: payload.graph,
      running: net.isRunning(),
      started: net.isStarted()
    }, context);
  }

};

module.exports = NetworkProtocol;
