var Base, DirectClient, DirectRuntime, EventEmitter, isBrowser;

isBrowser = function() {
  return !(typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1);
};

Base = require('./Base');

EventEmitter = require('events').EventEmitter;

DirectRuntime = class DirectRuntime extends Base {
  constructor(options) {
    super(options);
    this.clients = [];
  }

  _connect(client) {
    this.clients.push(client);
    return client.on('send', (msg) => {
      // Capture context
      return this._receive(msg, {
        client: client
      });
    });
  }

  _disconnect(client) {
    if (this.clients.indexOf(client) === -1) {
      return;
    }
    this.clients.splice(this.clients.indexOf(client), 1);
    return client.removeAllListeners('send'); // XXX: a bit heavy
  }

  _receive(msg, context) {
    // Forward to Base
    return this.receive(msg.protocol, msg.command, msg.payload, context);
  }

  send(protocol, topic, payload, context) {
    var m;
    if (!context.client) {
      return;
    }
    m = {
      protocol: protocol,
      command: topic,
      payload: payload
    };
    return context.client._receive(m);
  }

  sendAll(protocol, topic, payload) {
    var client, i, len, m, ref, results;
    m = {
      protocol: protocol,
      command: topic,
      payload: payload
    };
    ref = this.clients;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      client = ref[i];
      results.push(client._receive(m));
    }
    return results;
  }

};


// Mostly used for testing
DirectClient = class DirectClient extends EventEmitter {
  constructor(runtime, name) {
    super();
    this.name = name;
    this.runtime = runtime;
    if (!this.name) {
      this.name = 'Unnamed client';
    }
  }

  connect() {
    return this.runtime._connect(this);
  }

  disconnect() {
    return this.runtime._disconnect(this);
  }

  send(protocol, topic, payload) {
    var m;
    m = {
      protocol: protocol,
      command: topic,
      payload: payload
    };
    return this.emit('send', m);
  }

  _receive(message) {
    return setTimeout(() => {
      return this.emit('message', message);
    }, 1);
  }

};

exports.Client = DirectClient;

exports.Runtime = DirectRuntime;
