var Client, MessageBroker, amqp, async, bindingId, dataSubscriptionQueueName, debug, e, interfaces, uuid;

debug = require('debug')('msgflo:amqp');

async = require('async');

uuid = require('uuid');

interfaces = require('./interfaces');

try {
  amqp = require('amqplib/callback_api');
} catch (error) {
  e = error;
  amqp = e;
}

Client = class Client extends interfaces.MessagingClient {
  constructor(address, options = {}) {
    super(address, options);
    this.address = address;
    this.options = options;
    this.connection = null;
    this.channel = null;
    if (this.options.prefetch == null) {
      this.options.prefetch = 2;
    }
  }

  //# Broker connection management
  connect(callback) {
    debug('connect', this.address);
    if (amqp.message) {
      return callback(amqp);
    }
    return amqp.connect(this.address, (err, conn) => {
      debug('connected', err);
      if (err) {
        return callback(err);
      }
      this.connection = conn;
      return conn.createChannel((err, ch) => {
        debug('channel created', err);
        if (err) {
          return callback(err);
        }
        this.channel = ch;
        debug('setting prefetch', this.options.prefetch);
        this.channel.prefetch(this.options.prefetch);
        this.channel.on('close', function() {
          return debug('channel closed');
        });
        this.channel.on('error', function(err) {
          if (err) {
            throw err;
          }
        });
        return callback(null);
      });
    });
  }

  disconnect(callback) {
    debug('disconnect');
    if (!this.connection) {
      return callback(null);
    }
    if (!this.channel) {
      return callback(null);
    }
    return this.channel.close((err) => {
      debug('channel closed', err);
      this.channel = null;
      return this.connection.close((err) => {
        debug('connection closed');
        this.connection = null;
        return callback(err);
      });
    });
  }

  //# Manipulating queues
  createQueue(type, queueName, options, callback) {
    var exchangeName, exchangeOptions, queueOptions;
    if (!callback) {
      callback = options;
      options = {};
    }
    debug('create queue', type, queueName, options);
    queueOptions = {
      deadLetterExchange: 'dead-' + queueName // if not existing, messages will be dropped
    };
    exchangeOptions = {};
    exchangeName = queueName;
    if ((options.persistent != null) && !options.persistent) {
      queueOptions.durable = false;
      queueOptions.autoDelete = true;
      exchangeOptions.durable = false;
      exchangeOptions.autoDelete = true;
    }
    if (type === 'inqueue') {
      return this.channel.assertQueue(queueName, queueOptions, (err) => {
        // HACK: to make inqueue==outqueue work without binding.
        // Has side-effect of creating an implicit exchange.
        // Better than implicit queue, since a queue holds messages forever if noone is subscribed
        return this.channel.assertExchange(exchangeName, 'fanout', exchangeOptions, (err) => {
          if (err) {
            return callback(err);
          }
          return this.channel.bindQueue(exchangeName, queueName, '', {}, callback);
        });
      });
    } else {
      return this.channel.assertExchange(exchangeName, 'fanout', exchangeOptions, callback);
    }
  }

  removeQueue(type, queueName, callback) {
    var exchangeName;
    debug('remove queue', type, queueName);
    if (type === 'inqueue') {
      return this.channel.deleteQueue(queueName, {}, callback);
    } else {
      exchangeName = queueName;
      return this.channel.deleteExchange(exchangeName, {}, callback);
    }
  }

  //# Sending/Receiving messages
  sendTo(type, name, message, callback) {
    var data, dataShow, exchange, routingKey, showLimit;
    if (!this.channel) {
      return callback(new Error('msgflo.amqp.sendTo():  Not connected'));
    }
    // queue must exists
    data = new Buffer(JSON.stringify(message));
    showLimit = 80;
    dataShow = data.length > showLimit ? data.slice(0, showLimit) + '...' : data;
    debug('sendTo', type, name, dataShow);
    if (type === 'inqueue') {
      // direct to queue
      exchange = '';
      routingKey = name;
    } else {
      // to fanout exchange
      exchange = name;
      routingKey = '';
    }
    this.channel.publish(exchange, routingKey, data);
    return callback(null);
  }

  subscribeToQueue(queueName, handler, callback) {
    var deserialize;
    if (!this.channel) {
      return callback(new Error('msgflo.amqp.subscribeToQueue():  Not connected'));
    }
    debug('subscribe', queueName);
    // queue must exists
    deserialize = (message) => {
      var data, out;
      debug('receive on queue', queueName, message.fields.deliveryTag);
      data = null;
      try {
        data = JSON.parse(message.content.toString());
      } catch (error) {
        e = error;
        data = message.content.toString();
      }
      out = {
        amqp: message,
        data: data
      };
      return handler(out);
    };
    this.channel.consume(queueName, deserialize);
    debug('subscribed', queueName);
    return callback(null);
  }

  //# ACK/NACK messages
  ackMessage(message) {
    var fields;
    if (!this.channel) {
      return;
    }
    fields = message.amqp.fields;
    debug('ACK', fields.routingKey, fields.deliveryTag);
    // NOTE: server will only give us new message after this
    return this.channel.ack(message.amqp, false);
  }

  nackMessage(message) {
    var fields;
    if (!this.channel) {
      return;
    }
    fields = message.amqp.fields;
    debug('NACK', fields.routingKey, fields.deliveryTag);
    return this.channel.nack(message.amqp, false, false);
  }

  // Participant registration
  registerParticipant(part, callback) {
    var data, msg;
    msg = {
      protocol: 'discovery',
      command: 'participant',
      payload: part
    };
    this.channel.assertQueue('fbp');
    data = new Buffer(JSON.stringify(msg));
    this.channel.sendToQueue('fbp', data);
    return callback(null);
  }

};

dataSubscriptionQueueName = function(id) {
  if (!id) {
    throw new Error("Missing id");
  }
  return `.msgflo-broker-subscriptions-${id}`;
};

bindingId = function(b) {
  return `[${b.src}]->[${b.tgt}]`;
};

MessageBroker = class MessageBroker extends Client {
  constructor(address, options) {
    super(address, options);
    if (!this.options.id) {
      this.options.id = uuid.v4();
    }
    this.subscriptions = {};
  }

  connect(callback) {
    return super.connect((err) => {
      var name, options;
      if (err) {
        return callback(err);
      }
      // create queue for data subscriptions
      name = dataSubscriptionQueueName(this.options.id);
      options = {
        exclusive: true,
        durable: false,
        autoDelete: true
      };
      return this.channel.assertQueue(name, options, (err) => {
        var onSubscribedQueueData, subscribeOptions;
        if (err) {
          return callback(err);
        }
        onSubscribedQueueData = (message) => {
          var data, exchange, i, id, len, matches, results, sub;
          exchange = message.fields.exchange;
          debug('broker subscriber got message on exchange', exchange);
          matches = Object.keys(this.subscriptions).filter((id) => {
            var sub;
            sub = this.subscriptions[id];
            // XXX: how to account for which queue the message is for
            // can we create some identifier when we subscribe?
            return (sub != null ? sub.binding.src : void 0) === exchange;
          });
          results = [];
          for (i = 0, len = matches.length; i < len; i++) {
            id = matches[i];
            sub = this.subscriptions[id];
            data = message.content;
            try {
              data = JSON.parse(message.content.toString());
            } catch (error) {
              e = error;
              null;
            }
            results.push(sub.handler(sub.binding, data));
          }
          return results;
        };
        subscribeOptions = {
          noAck: true
        };
        return this.channel.consume(name, onSubscribedQueueData, subscribeOptions, function(err) {
          debug('broker created subscription queue', err);
          return callback(err);
        });
      });
    });
  }

  addBinding(binding, callback) {
    var bindDeadLetter, bindSrcTgt, pattern, steps;
    debug('Broker.addBinding', binding);
    if (binding.type === 'pubsub') {
      return this.channel.bindQueue(binding.tgt, binding.src, '', {}, callback);
    } else if (binding.type === 'roundrobin') {
      pattern = '';
      bindSrcTgt = (callback) => {
        var directExchange, directOptions;
        // TODO: avoid creating the direct exchange?
        debug('binding src to tgt', binding.src, binding.tgt);
        directExchange = 'out-' + binding.src;
        directOptions = {};
        return this.channel.assertExchange(directExchange, 'direct', directOptions, (err) => {
          if (err) {
            return callback(err);
          }
          // bind input
          return this.channel.bindExchange(directExchange, binding.src, pattern, err, () => {
            if (err) {
              return callback(err);
            }
            // bind output
            return this.channel.bindQueue(binding.tgt, directExchange, pattern, {}, (err) => {
              return callback(err);
            });
          });
        });
      };
      bindDeadLetter = (callback) => {
        var deadLetterExchange, deadLetterOptions;
        // Setup the deadletter exchange, bind to deadletter queue
        debug('binding deadletter queue', binding.deadletter, binding.tgt);
        deadLetterExchange = 'dead-' + binding.tgt;
        deadLetterOptions = {};
        return this.channel.assertExchange(deadLetterExchange, 'fanout', deadLetterOptions, (err) => {
          if (err) {
            return callback(err);
          }
          return this.channel.bindQueue(binding.deadletter, deadLetterExchange, pattern, {}, callback);
        });
      };
      steps = [];
      if (binding.src && binding.tgt) {
        steps.push(bindSrcTgt);
      }
      if (binding.deadletter && binding.tgt) {
        steps.push(bindDeadLetter);
      }
      return async.series(steps, callback);
    } else {
      return callback(new Error('Unsupported binding type: ' + binding.type));
    }
  }

  removeBinding(binding, callback) {
    debug('Broker.removeBinding', binding);
    if (binding.type === 'pubsub') {
      return this.channel.unbindQueue(binding.tgt, binding.src, '', {}, callback);
    } else if (binding.type === 'roundrobin') {
      return callback(new Error("removeBinding() not supported for type='roundrobin'")); // TODO:
    } else {
      return callback(new Error(`Unsupported binding type: ${binding.type}`));
    }
  }

  listBindings(from, callback) { // FIXME: implement
    // NOTE: probably need to use the RabbitMQ HTTP API for this
    return callback(null, []);
  }

  // Data subscriptions
  subscribeData(binding, datahandler, callback) {
    var exchange, options, queue;
    exchange = binding.src;
    queue = dataSubscriptionQueueName(this.options.id);
    options = {
      autoDelete: true
    };
    return this.channel.bindQueue(queue, exchange, '', options, (err) => {
      var id;
      if (err) {
        return callback(err);
      }
      id = bindingId(binding);
      this.subscriptions[id] = {
        binding: binding,
        handler: datahandler
      };
      return callback(null);
    });
  }

  unsubscribeData(binding, datahandler, callback) {
    var id;
    // TODO: also remove the subscription with broker
    id = bindingId(binding);
    delete this.subscriptions[id];
    return callback(null);
  }

  listSubscriptions(callback) {
    var id, ref, sub, subs;
    // Is there a way to get this information through AMQP?
    // Or do need to use RabbitMQ HTTP API?
    subs = [];
    ref = this.subscriptions;
    for (id in ref) {
      sub = ref[id];
      subs.push(sub.binding);
    }
    return callback(null, subs);
  }

  // Participant registration
  subscribeParticipantChange(handler) {
    var deserialize;
    deserialize = (message) => {
      var data, out;
      debug('receive on fbp', message.fields.deliveryTag);
      data = null;
      try {
        data = JSON.parse(message.content.toString());
      } catch (error) {
        e = error;
        debug('JSON exception:', e);
      }
      out = {
        amqp: message,
        data: data
      };
      return handler(out);
    };
    this.channel.assertQueue('fbp');
    return this.channel.consume('fbp', deserialize);
  }

};

exports.Client = Client;

exports.MessageBroker = MessageBroker;
