var EventEmitter, Participant, addQueues, async, common, debug, defaultDiscoveryPeriod, definitionToFbp, findPort, instantiateDefinition, newrelic, startParticipant, transport, uuid,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

common = require('./common');

transport = require('./transport');

newrelic = require('./newrelic');

debug = require('debug')('msgflo:participant');

async = require('async');

EventEmitter = require('events').EventEmitter;

uuid = require('uuid');

findPort = function(def, type, portName) {
  var i, len, port, ports;
  ports = type === 'inport' ? def.inports : def.outports;
  for (i = 0, len = ports.length; i < len; i++) {
    port = ports[i];
    if (port.id === portName) {
      return port;
    }
  }
  return null;
};

definitionToFbp = function(d) {
  var def, portsWithQueue;
  def = common.clone(d);
  portsWithQueue = function(ports) {
    // these cannot be wired, so should not show. For Sources/Sinks
    return ports.filter(function(p) {
      return p.queue != null;
    });
  };
  def.inports = portsWithQueue(def.inports);
  def.outports = portsWithQueue(def.outports);
  return def;
};

addQueues = function(ports, role) {
  var i, len, name, p;
  for (i = 0, len = ports.length; i < len; i++) {
    p = ports[i];
    if (p.hidden == null) {
      p.hidden = false;
    }
    name = role + '.' + p.id.toUpperCase();
    if (!p.queue && !p.hidden) {
      p.queue = name;
    }
  }
  return ports;
};

instantiateDefinition = function(d, role) {
  var def, id;
  def = common.clone(d);
  id = uuid.v4();
  def.role = role;
  if (!def.id) {
    def.id = `${def.role}-${id}`;
  }
  def.inports = addQueues(def.inports, def.role);
  def.outports = addQueues(def.outports, def.role);
  return def;
};

defaultDiscoveryPeriod = 60;

if (process.env.MSGFLO_DISCOVERY_PERIOD) {
  defaultDiscoveryPeriod = parseInt(process.env.MSGFLO_DISCOVERY_PERIOD);
}

Participant = class Participant extends EventEmitter {
  // @func gets called with inport, , and should return outport, outdata
  constructor(client, def, func, role, options = {}) {
    super();
    this.onResult = this.onResult.bind(this);
    this.func = func;
    if (typeof client === 'string') {
      client = transport.getClient(client);
    }
    this.messaging = client;
    if (!role) {
      role = 'unknown';
    }
    this.definition = instantiateDefinition(def, role);
    this.running = false;
    this._transactions = new newrelic.Transactions(this.definition);
    this.options = options;
    if (!this.options.discoveryPeriod) { // seconds
      this.options.discoveryPeriod = defaultDiscoveryPeriod;
    }
  }

  start(callback) {
    return this.messaging.connect((err) => {
      debug('connected', err);
      if (err) {
        return callback(err);
      }
      return this.setupPorts((err) => {
        this.running = true;
        if (err) {
          return callback(err);
        }
        return this.register((err) => {
          var period;
          if (err) {
            return callback(err);
          }
          period = this.options.discoveryPeriod * 1000 / 2.2; // try to send 2 messages before deadline
          setInterval(() => {
            return this.register(function(err) {
              if (err) {
                return console.log('Could not send discovery message', err);
              }
            });
          }, period);
          return callback(null);
        });
      });
    });
  }

  stop(callback) {
    this.running = false;
    return this.messaging.disconnect(callback);
  }

  // Send data on inport
  // Normally only used directly for Source type participants
  // For Transform or Sink type, is called on data from input queue
  send(inport, data, callback = function() {}) {
    debug('got msg from send()', inport);
    return this.func(inport, data, (outport, err, data) => {
      if (err) {
        return callback(err);
      }
      return this.onResult(outport, data, callback);
    });
  }

  // Emit data on outport
  emitData(outport, data) {
    return this.emit('data', outport, data);
  }

  onResult(outport, data, callback) {
    var port;
    boundMethodCheck(this, Participant);
    port = findPort(this.definition, 'outport', outport);
    this.emitData(port.id, data);
    if (port.queue) {
      return this.messaging.sendTo('outqueue', port.queue, data, callback);
    } else {
      return callback(null);
    }
  }

  setupPorts(callback) {
    var setupInPort, setupOutPort;
    setupOutPort = (def, callback) => {
      var options;
      if (!def.queue) {
        return callback(null);
      }
      options = {};
      if (def.persistent != null) {
        options.persistent = def.persistent;
      }
      return this.messaging.createQueue('outqueue', def.queue, options, callback);
    };
    setupInPort = (def, callback) => {
      var callFunc, options;
      if (!def.queue) {
        return callback(null);
      }
      callFunc = (msg) => {
        var msgid;
        debug('got msg from queue', def.queue);
        msgid = uuid.v4(); // need something cross-transport, only AMQP has deliveryTag
        this._transactions.open(msgid, def.id);
        return this.func(def.id, msg.data, (outport, err, data) => {
          this._transactions.close(msgid, outport);
          if (err) {
            debug('process() error', err.message);
          }
          if (err && (data == null)) {
            return this.messaging.nackMessage(msg);
          }
          return this.onResult(outport, data, (sendErr) => {
            if (err || sendErr) {
              return this.messaging.nackMessage(msg);
            }
            if (msg) {
              return this.messaging.ackMessage(msg);
            }
          });
        });
      };
      options = {};
      if (def.persistent != null) {
        options.persistent = def.persistent;
      }
      return this.messaging.createQueue('inqueue', def.queue, options, (err) => {
        if (err) {
          return callback(err);
        }
        this.messaging.subscribeToQueue(def.queue, callFunc, callback);
        return debug('subscribe to', def.queue);
      });
    };
    return async.map(this.definition.outports, setupOutPort, (err) => {
      if (err) {
        return callback(err);
      }
      return async.map(this.definition.inports, setupInPort, (err) => {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    });
  }

  register(callback) {
    var definition;
    // Send discovery package to broker on 'fbp' queue
    debug('register');
    definition = definitionToFbp(this.definition);
    return this.messaging.registerParticipant(definition, (err) => {
      debug('registered', err);
      return callback(err);
    });
  }

};

// TODO: consider making component api a bit more like NoFlo.WirePattern

// inputs = { portA: { data: dataA1, groups: ['A', '1'] }, portB: { data: B1 } }
// outfunc = (type, outputs) -> # type can be 'data', 'end'
// process(inputs, outfunc)

// Core ideas:
// groups attached to the packet, avoids separate lifetime handling, but still allows modification
// should one enforce use of promises? calling process returns a promise?
startParticipant = function(library, client, componentName, id, callback) {
  var component, part;
  debug('starting', componentName, id);
  component = library[componentName];
  if (component == null) {
    return callback(new Error(`No Participant factory in library for ${componentName}`));
  }
  part = component(client, id);
  return part.start(function(err) {
    return callback(err, part);
  });
};

exports.Participant = Participant;

exports.startParticipant = startParticipant;

exports.instantiateDefinition = instantiateDefinition;
