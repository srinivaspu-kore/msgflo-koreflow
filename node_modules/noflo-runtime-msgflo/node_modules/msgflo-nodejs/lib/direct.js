var Client, EventEmitter, MessageBroker, Queue, brokers, debug, interfaces, routing;

debug = require('debug')('msgflo:direct');

EventEmitter = require('events').EventEmitter;

interfaces = require('./interfaces');

routing = require('./routing');

brokers = {};

Client = class Client extends interfaces.MessagingClient {
  constructor(address, options) {
    super(address, options);
    this.address = address;
    this.options = options;
    //    console.log 'client', @address
    this.broker = null;
  }

  
  //# Broker connection management
  connect(callback) {
    debug('client connect');
    this.broker = brokers[this.address];
    return callback(null);
  }

  disconnect(callback) {
    debug('client disconnect');
    this.broker = null;
    return callback(null);
  }

  _assertBroker(callback) {
    var err;
    if (!this.broker) {
      err = new Error(`no broker connected ${this.address}`);
    }
    if (err) {
      return callback(err);
    }
  }

  //# Manipulating queues
  createQueue(type, queueName, options, callback) {
    if (!callback) {
      callback = options;
      options = {};
    }
    //    console.log 'client create queue', queueName
    this._assertBroker(callback);
    return this.broker.createQueue(type, queueName, callback);
  }

  removeQueue(type, queueName, callback) {
    this._assertBroker(callback);
    return this.broker.removeQueue(type, queueName, callback);
  }

  //# Sending/Receiving messages
  sendTo(type, queueName, message, callback) {
    debug('client sendTo', type, queueName);
    this._assertBroker(callback);
    return this.broker.sendTo(type, queueName, message, callback);
  }

  subscribeToQueue(queueName, handler, callback) {
    this._assertBroker(callback);
    return this.broker.subscribeToQueue(queueName, handler, callback);
  }

  //# ACK/NACK messages
  ackMessage(message) {}

  nackMessage(message) {}

  // Participant discovery
  registerParticipant(part, callback) {
    return this.createQueue('', 'fbp', (err) => {
      var msg;
      msg = {
        protocol: 'discovery',
        command: 'participant',
        payload: part
      };
      return this.sendTo('outqueue', 'fbp', msg, callback);
    });
  }

};

Queue = class Queue extends EventEmitter {
  constructor() {
    super();
  }

  send(msg) {
    return this._emitSend(msg);
  }

  _emitSend(msg) {
    return this.emit('message', msg);
  }

};

MessageBroker = class MessageBroker extends interfaces.MessageBroker {
  constructor(address) {
    super(address);
    this.address = address;
    routing.binderMixin(this);
    this.queues = {};
  }

  //    console.log 'broker', @address

  //# Broker connection management
  connect(callback) {
    debug('broker connect');
    brokers[this.address] = this;
    return callback(null);
  }

  disconnect(callback) {
    debug('broker disconnect');
    delete brokers[this.address];
    return callback(null);
  }

  //# Manipulating queues
  createQueue(type, queueName, callback) {
    if (this.queues[queueName] == null) {
      this.queues[queueName] = new Queue;
    }
    return callback(null);
  }

  removeQueue(type, queueName, callback) {
    delete this.queues[queueName];
    return callback(null);
  }

  //# Sending/Receiving messages
  sendTo(type, queueName, message, callback) {
    debug('broker sendTo', queueName);
    this.queues[queueName].send(message);
    return callback(null);
  }

  subscribeToQueue(queueName, handler, callback) {
    if (this.queues[queueName] == null) {
      this.queues[queueName] = new Queue;
    }
    this.queues[queueName].on('message', function(data) {
      var out;
      out = {
        direct: null,
        data: data
      };
      return handler(out);
    });
    return callback(null);
  }

  //# ACK/NACK messages
  ackMessage(message) {}

  nackMessage(message) {}

  subscribeParticipantChange(handler) {
    return this.createQueue('', 'fbp', (err) => {
      return this.subscribeToQueue('fbp', handler, function() {});
    });
  }

};

exports.MessageBroker = MessageBroker;

exports.Client = Client;
