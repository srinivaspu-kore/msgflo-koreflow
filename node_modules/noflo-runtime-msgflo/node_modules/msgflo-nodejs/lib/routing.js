var Binder, bindingId, debug;

debug = require('debug')('msgflo:routing');

// Used to bind one queue/exchange to another when the Broker
// of the transport cannot provide this functionality, like on MQTT

// TODO: split into two pieces
// a) a Router, which implements message routing
// with a message-queue based protocol for listing and manipulating bindings.
// b) a Binder mixin for MessageBroker inteface,
// which sends messsages on this protocol for add/removeBinding() and listBindings()

// This allows a single Router to exist in the network. It holds the canonical state of which
// queues/topics are bound to eachother, and multiple processes can query and manipulate these.
// Typically this would be hosted on the same machine as the Broker itself, and would have same lifetime.

// Protocol:
// (in) /msgrouter/$instance/addbinding      Add a new binding between a source and target topic/queue.
// (in) /msgrouter/$instance/removebinding   Remove an existing binding between a source and target topic/queue.
// (out) /msgrouter/$instance/bindings       Full list of current bindings. Emitted on changes, or when requested.
// (in) /msgrouter/$instance/listbindings    Explicitly request current bindings.

// The default $instance is 'default'
// The Router implementation should persist the bindings whenever they change.
// Upon restarting it should restore the persisted bindings (and emit a signal).

bindingId = function(f, t) {
  return `${f}-${t}`;
};

Binder = class Binder {
  constructor(transport1) {
    this.transport = transport1;
    this.bindings = {};
    this.subscriptions = {};
  }

  addBinding(binding, callback) {
    var from, handler, id, to;
    from = binding.src;
    to = binding.tgt;
    // TODO: handle non-pubsub types
    id = bindingId(from, to);
    debug('Binder.addBinding', binding.type, id);
    if (this.bindings[id]) {
      return callback(null);
    }
    handler = (msg) => {
      var i, len, ref, subCallback, subscription;
      binding = this.bindings[id];
      if (!(binding != null ? binding.enabled : void 0)) {
        return;
      }
      debug('edge message', from, to, msg);
      subscription = this.subscriptions[id];
      if (subscription) {
        ref = subscription.handlers;
        for (i = 0, len = ref.length; i < len; i++) {
          subCallback = ref[i];
          subCallback(subscription.binding, msg.data);
        }
      }
      if (from !== to) {
        return this.transport.sendTo('outqueue', to, msg.data, function(err) {
          if (err) {
            throw err;
          }
        });
      } else {

      }
    };
    // same topic/queue, data should appear without our forwarding
    return this.transport.subscribeToQueue(from, handler, (err) => {
      if (err) {
        return callback(err);
      }
      this.bindings[id] = {
        handler: handler,
        enabled: true
      };
      return callback(null);
    });
  }

  removeBinding(binding, callback) {
    var from, id, to;
    from = binding.src;
    to = binding.tgt;
    id = bindingId(from, to);
    debug('Binder.removeBinding', binding, id);
    binding = this.bindings[id];
    if (!binding) {
      return callback(new Error("Binding does not exist"));
    }
    binding.enabled = false;
    delete this.bindings[id];
    //FIXME: add an unsubscribeQueue to Client/transport, and use that
    return callback(null);
  }

  listBindings(callback) { // FIXME: implement
    debug('Binder.listBindings');
    return callback(null, []);
  }

  subscribeData(binding, datahandler, callback) {
    var id;
    id = bindingId(binding.src, binding.tgt);
    if (!this.subscriptions[id]) {
      this.subscriptions[id] = {
        handlers: [],
        binding: binding
      };
    }
    this.subscriptions[id].handlers.push(datahandler);
    return callback(null);
  }

  unsubscribeData(binding, datahandler, callback) {
    var handlerIndex, id, subscription;
    id = bindingId(binding.src, binding.tgt);
    subscription = this.subscriptions[id];
    handlerIndex = subscription.handlers.indexOf(datahandler);
    if (handlerIndex === -1) {
      return callback(new Error("Subscription was not found"));
    }
    subscription.handlers = subscription.handlers.splice(handlerIndex, 1);
    return callback(null);
  }

  listSubscriptions(callback) {
    var id, ref, sub, subs;
    subs = [];
    ref = this.subscriptions;
    for (id in ref) {
      sub = ref[id];
      subs.push(sub.binding);
    }
    return callback(null, subs);
  }

};

exports.Binder = Binder;

exports.binderMixin = function(transport) {
  var b;
  b = new Binder(transport);
  transport._binder = b;
  transport.addBinding = b.addBinding.bind(b);
  transport.removeBinding = b.removeBinding.bind(b);
  transport.listBindings = b.listBindings.bind(b);
  transport.subscribeData = b.subscribeData.bind(b);
  transport.unsubscribeData = b.unsubscribeData.bind(b);
  return transport.listSubscriptions = b.listSubscriptions.bind(b);
};
