var Client, MessageBroker, debug, e, interfaces, mqtt, routing;

debug = require('debug')('msgflo:mqtt');

interfaces = require('./interfaces');

routing = require('./routing');

try {
  mqtt = require('mqtt');
} catch (error) {
  e = error;
  mqtt = e;
}

Client = class Client extends interfaces.MessagingClient {
  constructor(address, options) {
    super(address, options);
    this.address = address;
    this.options = options;
    this.client = null;
    this.subscribers = {}; // queueName -> [handler1, ...]
  }

  
  //# Broker connection management
  connect(callback) {
    var onConnected;
    if (mqtt.message) {
      return callback(mqtt);
    }
    this.client = mqtt.connect(this.address);
    // debug
    this.client.on('reconnect', () => {
      return debug('reconnect');
    });
    this.client.on('offline', () => {
      return debug('offline');
    });
    this.client.on('error', (err) => {
      debug('error', err);
      if (callback) {
        callback(err);
        callback = null;
      }
    });
    onConnected = (connack) => {
      debug('connected');
      this.client.on('message', (topic, message) => {
        return this._onMessage(topic, message);
      });
      if (callback) {
        callback(null);
        callback = null;
      }
    };
    return this.client.once('connect', onConnected);
  }

  disconnect(callback) {
    this.client.removeAllListeners('message');
    this.client.removeAllListeners('connect');
    this.client.removeAllListeners('reconnect');
    this.client.removeAllListeners('offline');
    this.client.removeAllListeners('error');
    this.subscribers = {};
    return this.client.end((err) => {
      debug('disconnected');
      this.client = null;
      return callback(err);
    });
  }

  //# Manipulating queues
  createQueue(type, queueName, options, callback) {
    if (!callback) {
      callback = options;
      options = {};
    }
    // Noop, in MQTT one can send messages on 'topics' at any time
    return callback(null);
  }

  removeQueue(type, queueName, callback) {
    // Noop, in MQTT one can send messages on 'topics' at any time
    return callback(null);
  }

  //# Sending/Receiving messages
  sendTo(type, queueName, message, callback) {
    var data, published;
    published = (err, granted) => {
      debug('published', queueName, err, granted);
      if (err) {
        return callback(err);
      }
      return callback(null);
    };
    data = JSON.stringify(message);
    debug('publishing', queueName, data);
    return this.client.publish(queueName, data, published);
  }

  subscribeToQueue(queueName, handler, callback) {
    debug('subscribing', queueName);
    return this.client.subscribe(queueName, (err) => {
      var subs;
      debug('subscribed', queueName, err);
      if (err) {
        return callback(err);
      }
      subs = this.subscribers[queueName];
      if (subs) {
        subs.push(handler);
      } else {
        this.subscribers[queueName] = [handler];
      }
      return callback(null);
    });
  }

  //# ACK/NACK messages
  ackMessage(message) {}

  nackMessage(message) {}

  _onMessage(topic, message) {
    var handler, handlers, i, len, msg, out, results;
    if (!this.client) {
      return;
    }
    if (!Object.keys(this.subscribers).length > 0) {
      return;
    }
    msg = null;
    try {
      msg = JSON.parse(message.toString());
    } catch (error) {
      e = error;
      debug(`failed to parse incoming message on ${topic} as JSON`, e);
      msg = message.toString();
    }
    handlers = this.subscribers[topic];
    debug('message', handlers.length, msg !== null);
    if (!handlers) {
      return;
    }
    out = {
      data: msg,
      mqtt: message
    };
    results = [];
    for (i = 0, len = handlers.length; i < len; i++) {
      handler = handlers[i];
      results.push(handler(out));
    }
    return results;
  }

  registerParticipant(part, callback) {
    var msg;
    msg = {
      protocol: 'discovery',
      command: 'participant',
      payload: part
    };
    return this.sendTo('inqueue', 'fbp', msg, callback);
  }

};

MessageBroker = class MessageBroker extends Client {
  constructor(address, options) {
    super(address, options);
    routing.binderMixin(this);
  }

  // Participant registration
  subscribeParticipantChange(handler) {
    return this.createQueue('', 'fbp', (err) => {
      return this.subscribeToQueue('fbp', handler, function() {});
    });
  }

};

exports.Client = Client;

exports.MessageBroker = MessageBroker;
