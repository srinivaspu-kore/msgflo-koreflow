var BaseTransport, debugMessagingReceive, debugMessagingReceivePayload, debugMessagingSend, debugMessagingSendPayload, protocols;

protocols = {
  Runtime: require('./protocol/Runtime'),
  Graph: require('./protocol/Graph'),
  Network: require('./protocol/Network'),
  Component: require('./protocol/Component')
};

debugMessagingReceive = require('debug')('noflo-runtime-base:messaging:receive');

debugMessagingReceivePayload = require('debug')('noflo-runtime-base:messaging:receive:payload');

debugMessagingSend = require('debug')('noflo-runtime-base:messaging:send');

debugMessagingSendPayload = require('debug')('noflo-runtime-base:messaging:send:payload');

// This is the class all NoFlo runtime implementations can extend to easily wrap
// into any transport protocol.
BaseTransport = class BaseTransport {
  constructor(options) {
    var graphName;
    this.options = options;
    if (!this.options) {
      this.options = {};
    }
    this.version = '0.5';
    this.component = new protocols.Component(this);
    this.graph = new protocols.Graph(this);
    this.network = new protocols.Network(this);
    this.runtime = new protocols.Runtime(this);
    this.context = null;
    if (this.options.defaultGraph != null) {
      this.options.defaultGraph.baseDir = this.options.baseDir;
      graphName = 'default/main';
      this.context = 'none';
      this.graph.registerGraph(graphName, this.options.defaultGraph);
      this.network._startNetwork(this.options.defaultGraph, graphName, this.context, function(err) {
        if (err) {
          throw err;
        }
      });
    }
    if ((this.options.captureOutput != null) && this.options.captureOutput) {
      // Start capturing so that we can send it to the UI when it connects
      this.startCapture();
    }
    if (!this.options.defaultPermissions) {
      // Default: no capabilities granted for anonymous users
      this.options.defaultPermissions = [];
    }
    if (!this.options.permissions) {
      this.options.permissions = {};
    }
  }

  // Check if a given user is authorized for a given capability

  // @param [String] Capability to check
  // @param [String] Secret provided by user
  canDo(capability, secret) {
    var permitted;
    permitted = this.getPermitted(secret);
    if (permitted.indexOf(capability) !== -1) {
      return true;
    }
    return false;
  }

  // Get enabled capabilities for a user

  // @param [String] Secret provided by user
  getPermitted(secret) {
    if (!secret) {
      return this.options.defaultPermissions;
    }
    if (!this.options.permissions[secret]) {
      return [];
    }
    return this.options.permissions[secret];
  }

  // Send a message back to the user via the transport protocol.

  // Each transport implementation should provide their own implementation
  // of this method.

  // The context is usually the context originally received from the
  // transport with the request. This could be an iframe origin or a
  // specific WebSocket connection.

  // @param [String] Name of the protocol
  // @param [String] Topic of the message
  // @param [Object] Message payload
  // @param [Object] Message context, dependent on the transport
  send(protocol, topic, payload, context) {
    debugMessagingSend(`${protocol} ${topic}`);
    return debugMessagingSendPayload(payload);
  }

  
  // Send a message to *all users*  via the transport protocol

  // The transport should verify that the recipients are authorized to receive
  // the message by using the `canDo` method.

  // Like send() only it sends to all.
  // @param [Object] Message context, can be null
  sendAll(protocol, topic, payload, context) {}

  // This is the entry-point to actual protocol handlers. When receiving
  // a message, the runtime should call this to make the requested actions
  // happen

  // The context is originally received from the transport. This could be
  // an iframe origin or a specific WebSocket connection. The context will
  // be utilized when sending messages back to the requester.

  // @param [String] Name of the protocol
  // @param [String] Topic of the message
  // @param [Object] Message payload
  // @param [Object] Message context, dependent on the transport
  receive(protocol, topic, payload, context) {
    if (!payload) {
      payload = {};
    }
    debugMessagingReceive(`${protocol} ${topic}`);
    debugMessagingReceivePayload(payload);
    this.context = context;
    switch (protocol) {
      case 'runtime':
        return this.runtime.receive(topic, payload, context);
      case 'graph':
        return this.graph.receive(topic, payload, context);
      case 'network':
        return this.network.receive(topic, payload, context);
      case 'component':
        return this.component.receive(topic, payload, context);
    }
  }

};

module.exports = BaseTransport;

module.exports.trace = require('./trace');

module.exports.direct = require('./direct');
