var EventEmitter, RuntimeProtocol, findPort, noflo, portToPayload, portsPayload, sendToInport;

noflo = require('noflo');

EventEmitter = require('events').EventEmitter;

sendToInport = function(port, event, payload) {
  var socket;
  socket = noflo.internalSocket.createSocket();
  port.attach(socket);
  switch (event) {
    case 'begingroup':
      socket.beginGroup(payload);
      break;
    case 'endgroup':
      socket.endGroup(payload);
      break;
    case 'data':
      socket.send(payload);
  }
  return port.detach(socket);
};

findPort = function(network, name, inPort) {
  var component, internal, ref;
  if (!network.graph) {
    return;
  }
  if (inPort) {
    internal = network.graph.inports[name];
  } else {
    internal = network.graph.outports[name];
  }
  if (!(internal != null ? internal.process : void 0)) {
    return;
  }
  component = (ref = network.getNode(internal.process)) != null ? ref.component : void 0;
  if (!component) {
    return;
  }
  if (inPort) {
    return component.inPorts[internal.port];
  }
  return component.outPorts[internal.port];
};

portToPayload = function(pub, internal, network, inPort) {
  var def, port, ref, ref1;
  def = {
    id: pub,
    type: 'all',
    description: (ref = internal.metadata) != null ? ref.description : void 0,
    addressable: false,
    required: false
  };
  port = findPort(network, pub, inPort);
  if (!port) {
    // Network has been prepared but isn't running yet so
    // we don't have full component info
    return def;
  }
  def.type = port.getDataType();
  if (port.getSchema) {
    def.schema = port.getSchema();
  }
  def.description = ((ref1 = internal.metadata) != null ? ref1.description : void 0) || port.getDescription();
  def.addressable = port.isAddressable();
  def.required = port.isRequired();
  return def;
};

portsPayload = function(name, network) {
  var internal, payload, pub, ref, ref1;
  payload = {
    graph: name,
    inPorts: [],
    outPorts: []
  };
  if (!(network != null ? network.graph : void 0)) {
    return payload;
  }
  ref = network.graph.inports;
  for (pub in ref) {
    internal = ref[pub];
    payload.inPorts.push(portToPayload(pub, internal, network, true));
  }
  ref1 = network.graph.outports;
  for (pub in ref1) {
    internal = ref1[pub];
    payload.outPorts.push(portToPayload(pub, internal, network, false));
  }
  return payload;
};

RuntimeProtocol = class RuntimeProtocol extends EventEmitter {
  constructor(transport) {
    super();
    this.transport = transport;
    this.outputSockets = {}; // graphName -> publicPort -> noflo.Socket
    this.mainGraph = null;
    this.transport.network.on('addnetwork', (network, name) => {
      this.subscribeExportedPorts(name, network, true);
      this.subscribeOutPorts(name, network);
      this.sendPorts(name, network);
      if (network.isStarted()) {
        // processes don't exist until started
        this.subscribeOutdata(name, network, true);
      }
      return network.on('start', () => {
        // processes don't exist until started
        return this.subscribeOutdata(name, network, true);
      });
    });
    this.transport.network.on('removenetwork', (network, name) => {
      this.subscribeOutdata(name, network, false);
      this.subscribeOutPorts(name, network);
      this.subscribeExportedPorts(name, network.graph, false);
      return this.sendPorts(name, null);
    });
  }

  send(topic, payload, context) {
    return this.transport.send('runtime', topic, payload, context);
  }

  sendAll(topic, payload) {
    return this.transport.sendAll('runtime', topic, payload);
  }

  sendError(message, context) {
    return this.send('error', new Error(message), context);
  }

  receive(topic, payload, context) {
    if (topic === 'packet' && !this.transport.canDo('protocol:runtime', payload.secret)) {
      this.send('error', new Error(`${topic} not permitted`), context);
      return;
    }
    switch (topic) {
      case 'getruntime':
        return this.getRuntime(payload, context);
      case 'packet':
        return this.sendPacket(payload, (err) => {
          if (err) {
            this.sendError(err.message, context);
          }
        });
    }
  }

  getRuntime(payload, context) {
    var capabilities, name, network, permittedCapabilities, ref, results, type;
    type = this.transport.options.type;
    if (!type) {
      if (noflo.isBrowser()) {
        type = 'noflo-browser';
      } else {
        type = 'noflo-nodejs';
      }
    }
    capabilities = this.transport.options.capabilities;
    if (!capabilities) {
      capabilities = ['protocol:graph', 'protocol:component', 'protocol:network', 'protocol:runtime', 'component:setsource', 'component:getsource'];
    }
    permittedCapabilities = capabilities.filter((capability) => {
      return this.transport.canDo(capability, payload.secret);
    });
    payload = {
      type: type,
      version: this.transport.version,
      capabilities: permittedCapabilities,
      allCapabilities: capabilities
    };
    if (this.mainGraph) {
      payload.graph = this.mainGraph;
    }
    if (this.transport.options.id) {
      // Add project metadata if available
      payload.id = this.transport.options.id;
    }
    if (this.transport.options.label) {
      payload.label = this.transport.options.label;
    }
    if (this.transport.options.namespace) {
      payload.namespace = this.transport.options.namespace;
    }
    if (this.transport.options.repository) {
      payload.repository = this.transport.options.repository;
    }
    if (this.transport.options.repositoryVersion) {
      payload.repositoryVersion = this.transport.options.repositoryVersion;
    }
    this.send('runtime', payload, context);
    ref = this.transport.network.networks;
    // send port info about currently set up networks
    results = [];
    for (name in ref) {
      network = ref[name];
      results.push(this.sendPorts(name, network, context));
    }
    return results;
  }

  sendPorts(name, network, context) {
    var payload;
    payload = portsPayload(name, network);
    this.emit('ports', payload);
    if (!context) {
      return this.sendAll('ports', payload);
    } else {
      return this.send('ports', payload, context);
    }
  }

  setMainGraph(id) {
    return this.mainGraph = id;
  }

  // XXX: should send updated runtime info?
  subscribeExportedPorts(name, network, add) {
    var d, dependencies, i, j, len, len1, results, sendExportedPorts;
    sendExportedPorts = () => {
      return this.sendPorts(name, network);
    };
    dependencies = ['addInport', 'addOutport', 'removeInport', 'removeOutport'];
    for (i = 0, len = dependencies.length; i < len; i++) {
      d = dependencies[i];
      network.graph.removeListener(d, sendExportedPorts);
    }
    if (add) {
      results = [];
      for (j = 0, len1 = dependencies.length; j < len1; j++) {
        d = dependencies[j];
        results.push(network.graph.on(d, sendExportedPorts));
      }
      return results;
    }
  }

  subscribeOutPorts(name, network, add) {
    var graph, portAdded, portRemoved;
    portRemoved = () => {
      return this.subscribeOutdata(name, network, false);
    };
    portAdded = () => {
      return this.subscribeOutdata(name, network, true);
    };
    graph = network.graph;
    graph.removeListener('addOutport', portAdded);
    graph.removeListener('removeOutport', portRemoved);
    if (add) {
      graph.on('addOutport', portAdded);
      return graph.on('removeOutport', portRemoved);
    }
  }

  subscribeOutdata(graphName, network, add) {
    var event, graphSockets, i, len, pub, socket;
    if (!this.outputSockets[graphName]) {
      // Unsubscribe all
      this.outputSockets[graphName] = {};
    }
    graphSockets = this.outputSockets[graphName];
    for (pub in graphSockets) {
      socket = graphSockets[pub];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        socket.removeAllListeners(event);
      }
    }
    graphSockets = {};
    if (!add) {
      return;
    }
    // Subscribe new
    return Object.keys(network.graph.outports).forEach((pub) => {
      var component, internal;
      internal = network.graph.outports[pub];
      socket = noflo.internalSocket.createSocket();
      graphSockets[pub] = socket;
      component = network.processes[internal.process].component;
      component.outPorts[internal.port].attach(socket);
      return socket.on('ip', (ip) => {
        switch (ip.type) {
          case 'openBracket':
            event = 'begingroup';
            break;
          case 'closeBracket':
            event = 'endgroup';
            break;
          default:
            event = ip.type;
        }
        this.emit('packet', {
          port: pub,
          event: event,
          graph: graphName,
          payload: ip.data
        });
        return this.sendAll('packet', {
          port: pub,
          event: event,
          graph: graphName,
          payload: ip.data
        });
      });
    });
  }

  sendPacket(payload, callback) {
    var network, port;
    network = this.transport.network.networks[payload.graph];
    if (!network) {
      return callback(new Error(`Cannot find network for graph ${payload.graph}`));
    }
    port = findPort(network.network, payload.port, true);
    if (!port) {
      return callback(new Error(`Cannot find internal port for ${payload.port}`));
    }
    return sendToInport(port, payload.event, payload.payload);
  }

};

module.exports = RuntimeProtocol;
