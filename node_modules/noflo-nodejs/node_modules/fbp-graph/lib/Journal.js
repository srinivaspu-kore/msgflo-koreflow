  //     FBP Graph Journal
  //     (c) 2016-2017 Flowhub UG
  //     (c) 2014 Jon Nordby
  //     (c) 2013 Flowhub UG
  //     (c) 2011-2012 Henri Bergius, Nemein
  //     FBP Graph may be freely distributed under the MIT license

var EventEmitter, Journal, JournalStore, MemoryJournalStore, calculateMeta, clone, entryToPrettyString,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

({EventEmitter} = require('events'));

clone = require('clone');

entryToPrettyString = function(entry) {
  var a;
  a = entry.args;
  switch (entry.cmd) {
    case 'addNode':
      return `${a.id}(${a.component})`;
    case 'removeNode':
      return `DEL ${a.id}(${a.component})`;
    case 'renameNode':
      return `RENAME ${a.oldId} ${a.newId}`;
    case 'changeNode':
      return `META ${a.id}`;
    case 'addEdge':
      return `${a.from.node} ${a.from.port} -> ${a.to.port} ${a.to.node}`;
    case 'removeEdge':
      return `${a.from.node} ${a.from.port} -X> ${a.to.port} ${a.to.node}`;
    case 'changeEdge':
      return `META ${a.from.node} ${a.from.port} -> ${a.to.port} ${a.to.node}`;
    case 'addInitial':
      return `'${a.from.data}' -> ${a.to.port} ${a.to.node}`;
    case 'removeInitial':
      return `'${a.from.data}' -X> ${a.to.port} ${a.to.node}`;
    case 'startTransaction':
      return `>>> ${entry.rev}: ${a.id}`;
    case 'endTransaction':
      return `<<< ${entry.rev}: ${a.id}`;
    case 'changeProperties':
      return "PROPERTIES";
    case 'addGroup':
      return `GROUP ${a.name}`;
    case 'renameGroup':
      return `RENAME GROUP ${a.oldName} ${a.newName}`;
    case 'removeGroup':
      return `DEL GROUP ${a.name}`;
    case 'changeGroup':
      return `META GROUP ${a.name}`;
    case 'addInport':
      return `INPORT ${a.name}`;
    case 'removeInport':
      return `DEL INPORT ${a.name}`;
    case 'renameInport':
      return `RENAME INPORT ${a.oldId} ${a.newId}`;
    case 'changeInport':
      return `META INPORT ${a.name}`;
    case 'addOutport':
      return `OUTPORT ${a.name}`;
    case 'removeOutport':
      return `DEL OUTPORT ${a.name}`;
    case 'renameOutport':
      return `RENAME OUTPORT ${a.oldId} ${a.newId}`;
    case 'changeOutport':
      return `META OUTPORT ${a.name}`;
    default:
      throw new Error(`Unknown journal entry: ${entry.cmd}`);
  }
};

// To set, not just update (append) metadata
calculateMeta = function(oldMeta, newMeta) {
  var k, setMeta, v;
  setMeta = {};
  for (k in oldMeta) {
    v = oldMeta[k];
    setMeta[k] = null;
  }
  for (k in newMeta) {
    v = newMeta[k];
    setMeta[k] = v;
  }
  return setMeta;
};

JournalStore = (function() {
  class JournalStore extends EventEmitter {
    constructor(graph) {
      super();
      this.graph = graph;
      this.lastRevision = 0;
    }

    putTransaction(revId, entries) {
      if (revId > this.lastRevision) {
        this.lastRevision = revId;
      }
      return this.emit('transaction', revId);
    }

    fetchTransaction(revId, entries) {}

  };

  JournalStore.prototype.lastRevision = 0;

  return JournalStore;

}).call(this);

MemoryJournalStore = class MemoryJournalStore extends JournalStore {
  constructor(graph) {
    super(graph);
    this.transactions = [];
  }

  putTransaction(revId, entries) {
    super.putTransaction(revId, entries);
    return this.transactions[revId] = entries;
  }

  fetchTransaction(revId) {
    return this.transactions[revId];
  }

};

Journal = (function() {
  // ## Journalling graph changes

  // The Journal can follow graph changes, store them
  // and allows to recall previous revisions of the graph.

  // Revisions stored in the journal follow the transactions of the graph.
  // It is not possible to operate on smaller changes than individual transactions.
  // Use startTransaction and endTransaction on Graph to structure the revisions logical changesets.
  class Journal extends EventEmitter {
    constructor(graph, metadata, store) {
      var edge, group, iip, j, k, l, len, len1, len2, len3, m, n, node, ref, ref1, ref2, ref3, ref4, ref5, v;
      super();
      this.startTransaction = this.startTransaction.bind(this);
      this.endTransaction = this.endTransaction.bind(this);
      this.graph = graph;
      this.entries = [];
      this.subscribed = true;
      this.store = store || new MemoryJournalStore(this.graph);
      if (this.store.transactions.length === 0) {
        // Sync journal with current graph to start transaction history
        this.currentRevision = -1;
        this.startTransaction('initial', metadata);
        ref = this.graph.nodes;
        for (j = 0, len = ref.length; j < len; j++) {
          node = ref[j];
          this.appendCommand('addNode', node);
        }
        ref1 = this.graph.edges;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          edge = ref1[l];
          this.appendCommand('addEdge', edge);
        }
        ref2 = this.graph.initializers;
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          iip = ref2[m];
          this.appendCommand('addInitial', iip);
        }
        if (Object.keys(this.graph.properties).length > 0) {
          this.appendCommand('changeProperties', this.graph.properties, {});
        }
        ref3 = this.graph.inports;
        for (k in ref3) {
          v = ref3[k];
          this.appendCommand('addInport', {
            name: k,
            port: v
          });
        }
        ref4 = this.graph.outports;
        for (k in ref4) {
          v = ref4[k];
          this.appendCommand('addOutport', {
            name: k,
            port: v
          });
        }
        ref5 = this.graph.groups;
        for (n = 0, len3 = ref5.length; n < len3; n++) {
          group = ref5[n];
          this.appendCommand('addGroup', group);
        }
        this.endTransaction('initial', metadata);
      } else {
        // Persistent store, start with its latest rev
        this.currentRevision = this.store.lastRevision;
      }
      // Subscribe to graph changes
      this.graph.on('addNode', (node) => {
        return this.appendCommand('addNode', node);
      });
      this.graph.on('removeNode', (node) => {
        return this.appendCommand('removeNode', node);
      });
      this.graph.on('renameNode', (oldId, newId) => {
        var args;
        args = {
          oldId: oldId,
          newId: newId
        };
        return this.appendCommand('renameNode', args);
      });
      this.graph.on('changeNode', (node, oldMeta) => {
        return this.appendCommand('changeNode', {
          id: node.id,
          new: node.metadata,
          old: oldMeta
        });
      });
      this.graph.on('addEdge', (edge) => {
        return this.appendCommand('addEdge', edge);
      });
      this.graph.on('removeEdge', (edge) => {
        return this.appendCommand('removeEdge', edge);
      });
      this.graph.on('changeEdge', (edge, oldMeta) => {
        return this.appendCommand('changeEdge', {
          from: edge.from,
          to: edge.to,
          new: edge.metadata,
          old: oldMeta
        });
      });
      this.graph.on('addInitial', (iip) => {
        return this.appendCommand('addInitial', iip);
      });
      this.graph.on('removeInitial', (iip) => {
        return this.appendCommand('removeInitial', iip);
      });
      this.graph.on('changeProperties', (newProps, oldProps) => {
        return this.appendCommand('changeProperties', {
          new: newProps,
          old: oldProps
        });
      });
      this.graph.on('addGroup', (group) => {
        return this.appendCommand('addGroup', group);
      });
      this.graph.on('renameGroup', (oldName, newName) => {
        return this.appendCommand('renameGroup', {
          oldName: oldName,
          newName: newName
        });
      });
      this.graph.on('removeGroup', (group) => {
        return this.appendCommand('removeGroup', group);
      });
      this.graph.on('changeGroup', (group, oldMeta) => {
        return this.appendCommand('changeGroup', {
          name: group.name,
          new: group.metadata,
          old: oldMeta
        });
      });
      this.graph.on('addExport', (exported) => {
        return this.appendCommand('addExport', exported);
      });
      this.graph.on('removeExport', (exported) => {
        return this.appendCommand('removeExport', exported);
      });
      this.graph.on('addInport', (name, port) => {
        return this.appendCommand('addInport', {
          name: name,
          port: port
        });
      });
      this.graph.on('removeInport', (name, port) => {
        return this.appendCommand('removeInport', {
          name: name,
          port: port
        });
      });
      this.graph.on('renameInport', (oldId, newId) => {
        return this.appendCommand('renameInport', {
          oldId: oldId,
          newId: newId
        });
      });
      this.graph.on('changeInport', (name, port, oldMeta) => {
        return this.appendCommand('changeInport', {
          name: name,
          new: port.metadata,
          old: oldMeta
        });
      });
      this.graph.on('addOutport', (name, port) => {
        return this.appendCommand('addOutport', {
          name: name,
          port: port
        });
      });
      this.graph.on('removeOutport', (name, port) => {
        return this.appendCommand('removeOutport', {
          name: name,
          port: port
        });
      });
      this.graph.on('renameOutport', (oldId, newId) => {
        return this.appendCommand('renameOutport', {
          oldId: oldId,
          newId: newId
        });
      });
      this.graph.on('changeOutport', (name, port, oldMeta) => {
        return this.appendCommand('changeOutport', {
          name: name,
          new: port.metadata,
          old: oldMeta
        });
      });
      this.graph.on('startTransaction', (id, meta) => {
        return this.startTransaction(id, meta);
      });
      this.graph.on('endTransaction', (id, meta) => {
        return this.endTransaction(id, meta);
      });
    }

    startTransaction(id, meta) {
      boundMethodCheck(this, Journal);
      if (!this.subscribed) {
        return;
      }
      if (this.entries.length > 0) {
        throw Error("Inconsistent @entries");
      }
      this.currentRevision++;
      return this.appendCommand('startTransaction', {
        id: id,
        metadata: meta
      }, this.currentRevision);
    }

    endTransaction(id, meta) {
      boundMethodCheck(this, Journal);
      if (!this.subscribed) {
        return;
      }
      this.appendCommand('endTransaction', {
        id: id,
        metadata: meta
      }, this.currentRevision);
      // TODO: this would be the place to refine @entries into
      // a minimal set of changes, like eliminating changes early in transaction
      // which were later reverted/overwritten
      this.store.putTransaction(this.currentRevision, this.entries);
      return this.entries = [];
    }

    appendCommand(cmd, args, rev) {
      var entry;
      if (!this.subscribed) {
        return;
      }
      entry = {
        cmd: cmd,
        args: clone(args)
      };
      if (rev != null) {
        entry.rev = rev;
      }
      return this.entries.push(entry);
    }

    executeEntry(entry) {
      var a;
      a = entry.args;
      switch (entry.cmd) {
        case 'addNode':
          return this.graph.addNode(a.id, a.component);
        case 'removeNode':
          return this.graph.removeNode(a.id);
        case 'renameNode':
          return this.graph.renameNode(a.oldId, a.newId);
        case 'changeNode':
          return this.graph.setNodeMetadata(a.id, calculateMeta(a.old, a.new));
        case 'addEdge':
          return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
        case 'removeEdge':
          return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
        case 'changeEdge':
          return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a.old, a.new));
        case 'addInitial':
          return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
        case 'removeInitial':
          return this.graph.removeInitial(a.to.node, a.to.port);
        case 'startTransaction':
          return null;
        case 'endTransaction':
          return null;
        case 'changeProperties':
          return this.graph.setProperties(a.new);
        case 'addGroup':
          return this.graph.addGroup(a.name, a.nodes, a.metadata);
        case 'renameGroup':
          return this.graph.renameGroup(a.oldName, a.newName);
        case 'removeGroup':
          return this.graph.removeGroup(a.name);
        case 'changeGroup':
          return this.graph.setGroupMetadata(a.name, calculateMeta(a.old, a.new));
        case 'addInport':
          return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
        case 'removeInport':
          return this.graph.removeInport(a.name);
        case 'renameInport':
          return this.graph.renameInport(a.oldId, a.newId);
        case 'changeInport':
          return this.graph.setInportMetadata(a.name, calculateMeta(a.old, a.new));
        case 'addOutport':
          return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata(a.name));
        case 'removeOutport':
          return this.graph.removeOutport;
        case 'renameOutport':
          return this.graph.renameOutport(a.oldId, a.newId);
        case 'changeOutport':
          return this.graph.setOutportMetadata(a.name, calculateMeta(a.old, a.new));
        default:
          throw new Error(`Unknown journal entry: ${entry.cmd}`);
      }
    }

    executeEntryInversed(entry) {
      var a;
      a = entry.args;
      switch (entry.cmd) {
        case 'addNode':
          return this.graph.removeNode(a.id);
        case 'removeNode':
          return this.graph.addNode(a.id, a.component);
        case 'renameNode':
          return this.graph.renameNode(a.newId, a.oldId);
        case 'changeNode':
          return this.graph.setNodeMetadata(a.id, calculateMeta(a.new, a.old));
        case 'addEdge':
          return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
        case 'removeEdge':
          return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
        case 'changeEdge':
          return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a.new, a.old));
        case 'addInitial':
          return this.graph.removeInitial(a.to.node, a.to.port);
        case 'removeInitial':
          return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
        case 'startTransaction':
          return null;
        case 'endTransaction':
          return null;
        case 'changeProperties':
          return this.graph.setProperties(a.old);
        case 'addGroup':
          return this.graph.removeGroup(a.name);
        case 'renameGroup':
          return this.graph.renameGroup(a.newName, a.oldName);
        case 'removeGroup':
          return this.graph.addGroup(a.name, a.nodes, a.metadata);
        case 'changeGroup':
          return this.graph.setGroupMetadata(a.name, calculateMeta(a.new, a.old));
        case 'addInport':
          return this.graph.removeInport(a.name);
        case 'removeInport':
          return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
        case 'renameInport':
          return this.graph.renameInport(a.newId, a.oldId);
        case 'changeInport':
          return this.graph.setInportMetadata(a.name, calculateMeta(a.new, a.old));
        case 'addOutport':
          return this.graph.removeOutport(a.name);
        case 'removeOutport':
          return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata);
        case 'renameOutport':
          return this.graph.renameOutport(a.newId, a.oldId);
        case 'changeOutport':
          return this.graph.setOutportMetadata(a.name, calculateMeta(a.new, a.old));
        default:
          throw new Error(`Unknown journal entry: ${entry.cmd}`);
      }
    }

    moveToRevision(revId) {
      var entries, entry, i, j, l, len, m, n, r, ref, ref1, ref2, ref3, ref4, ref5;
      if (revId === this.currentRevision) {
        return;
      }
      this.subscribed = false;
      if (revId > this.currentRevision) {
// Forward replay journal to revId
        for (r = j = ref = this.currentRevision + 1, ref1 = revId; (ref <= ref1 ? j <= ref1 : j >= ref1); r = ref <= ref1 ? ++j : --j) {
          ref2 = this.store.fetchTransaction(r);
          for (l = 0, len = ref2.length; l < len; l++) {
            entry = ref2[l];
            this.executeEntry(entry);
          }
        }
      } else {
// Move backwards, and apply inverse changes
        for (r = m = ref3 = this.currentRevision, ref4 = revId + 1; m >= ref4; r = m += -1) {
          entries = this.store.fetchTransaction(r);
          for (i = n = ref5 = entries.length - 1; n >= 0; i = n += -1) {
            this.executeEntryInversed(entries[i]);
          }
        }
      }
      this.currentRevision = revId;
      return this.subscribed = true;
    }

    // ## Undoing & redoing
    // Undo the last graph change
    undo() {
      if (!this.canUndo()) {
        return;
      }
      return this.moveToRevision(this.currentRevision - 1);
    }

    // If there is something to undo
    canUndo() {
      return this.currentRevision > 0;
    }

    // Redo the last undo
    redo() {
      if (!this.canRedo()) {
        return;
      }
      return this.moveToRevision(this.currentRevision + 1);
    }

    // If there is something to redo
    canRedo() {
      return this.currentRevision < this.store.lastRevision;
    }

    //# Serializing
    // Render a pretty printed string of the journal. Changes are abbreviated
    toPrettyString(startRev, endRev) {
      var e, entry, j, l, len, lines, r, ref, ref1;
      startRev |= 0;
      endRev |= this.store.lastRevision;
      lines = [];
      for (r = j = ref = startRev, ref1 = endRev; (ref <= ref1 ? j < ref1 : j > ref1); r = ref <= ref1 ? ++j : --j) {
        e = this.store.fetchTransaction(r);
        for (l = 0, len = e.length; l < len; l++) {
          entry = e[l];
          lines.push(entryToPrettyString(entry));
        }
      }
      return lines.join('\n');
    }

    // Serialize journal to JSON
    toJSON(startRev, endRev) {
      var entries, entry, j, l, len, r, ref, ref1, ref2;
      startRev |= 0;
      endRev |= this.store.lastRevision;
      entries = [];
      for (r = j = ref = startRev, ref1 = endRev; j < ref1; r = j += 1) {
        ref2 = this.store.fetchTransaction(r);
        for (l = 0, len = ref2.length; l < len; l++) {
          entry = ref2[l];
          entries.push(entryToPrettyString(entry));
        }
      }
      return entries;
    }

    save(file, success) {
      var json;
      json = JSON.stringify(this.toJSON(), null, 4);
      return require('fs').writeFile(`${file}.json`, json, "utf-8", function(err, data) {
        if (err) {
          throw err;
        }
        return success(file);
      });
    }

  };

  Journal.prototype.graph = null;

  Journal.prototype.entries = [];

  Journal.prototype.subscribed = true; // Whether we should respond to graph change notifications or not

  return Journal;

}).call(this);

exports.Journal = Journal;

exports.JournalStore = JournalStore;

exports.MemoryJournalStore = MemoryJournalStore;
