(function() {
  var Client, MessageBroker, amqp, async, bindingId, dataSubscriptionQueueName, debug, e, error, interfaces, uuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = require('debug')('msgflo:amqp');

  async = require('async');

  uuid = require('uuid');

  interfaces = require('./interfaces');

  try {
    amqp = require('amqplib/callback_api');
  } catch (error) {
    e = error;
    amqp = e;
  }

  Client = (function(superClass) {
    extend(Client, superClass);

    function Client(address1, options1) {
      this.address = address1;
      this.options = options1 != null ? options1 : {};
      this.connection = null;
      this.channel = null;
      if (this.options.prefetch == null) {
        this.options.prefetch = 2;
      }
    }

    Client.prototype.connect = function(callback) {
      debug('connect', this.address);
      if (amqp.message) {
        return callback(amqp);
      }
      return amqp.connect(this.address, (function(_this) {
        return function(err, conn) {
          debug('connected', err);
          if (err) {
            return callback(err);
          }
          _this.connection = conn;
          return conn.createChannel(function(err, ch) {
            debug('channel created', err);
            if (err) {
              return callback(err);
            }
            _this.channel = ch;
            debug('setting prefetch', _this.options.prefetch);
            _this.channel.prefetch(_this.options.prefetch);
            _this.channel.on('close', function() {
              return debug('channel closed');
            });
            _this.channel.on('error', function(err) {
              if (err) {
                throw err;
              }
            });
            return callback(null);
          });
        };
      })(this));
    };

    Client.prototype.disconnect = function(callback) {
      debug('disconnect');
      if (!this.connection) {
        return callback(null);
      }
      if (!this.channel) {
        return callback(null);
      }
      return this.channel.close((function(_this) {
        return function(err) {
          debug('channel closed', err);
          _this.channel = null;
          return _this.connection.close(function(err) {
            debug('connection closed');
            _this.connection = null;
            return callback(err);
          });
        };
      })(this));
    };

    Client.prototype.createQueue = function(type, queueName, options, callback) {
      var exchangeName, exchangeOptions, queueOptions;
      if (!callback) {
        callback = options;
        options = {};
      }
      debug('create queue', type, queueName, options);
      queueOptions = {
        deadLetterExchange: 'dead-' + queueName
      };
      exchangeOptions = {};
      exchangeName = queueName;
      if ((options.persistent != null) && !options.persistent) {
        queueOptions.durable = false;
        queueOptions.autoDelete = true;
        exchangeOptions.durable = false;
        exchangeOptions.autoDelete = true;
      }
      if (type === 'inqueue') {
        return this.channel.assertQueue(queueName, queueOptions, (function(_this) {
          return function(err) {
            return _this.channel.assertExchange(exchangeName, 'fanout', exchangeOptions, function(err) {
              if (err) {
                return callback(err);
              }
              return _this.channel.bindQueue(exchangeName, queueName, '', {}, callback);
            });
          };
        })(this));
      } else {
        return this.channel.assertExchange(exchangeName, 'fanout', exchangeOptions, callback);
      }
    };

    Client.prototype.removeQueue = function(type, queueName, callback) {
      var exchangeName;
      debug('remove queue', type, queueName);
      if (type === 'inqueue') {
        return this.channel.deleteQueue(queueName, {}, callback);
      } else {
        exchangeName = queueName;
        return this.channel.deleteExchange(exchangeName, {}, callback);
      }
    };

    Client.prototype.sendTo = function(type, name, message, callback) {
      var data, dataShow, exchange, routingKey, showLimit;
      if (!this.channel) {
        return callback(new Error('msgflo.amqp.sendTo():  Not connected'));
      }
      data = new Buffer(JSON.stringify(message));
      showLimit = 80;
      dataShow = data.length > showLimit ? data.slice(0, showLimit) + '...' : data;
      debug('sendTo', type, name, dataShow);
      if (type === 'inqueue') {
        exchange = '';
        routingKey = name;
      } else {
        exchange = name;
        routingKey = '';
      }
      this.channel.publish(exchange, routingKey, data);
      return callback(null);
    };

    Client.prototype.subscribeToQueue = function(queueName, handler, callback) {
      var deserialize;
      if (!this.channel) {
        return callback(new Error('msgflo.amqp.subscribeToQueue():  Not connected'));
      }
      debug('subscribe', queueName);
      deserialize = (function(_this) {
        return function(message) {
          var data, error1, out;
          debug('receive on queue', queueName, message.fields.deliveryTag);
          data = null;
          try {
            data = JSON.parse(message.content.toString());
          } catch (error1) {
            e = error1;
            data = message.content.toString();
          }
          out = {
            amqp: message,
            data: data
          };
          return handler(out);
        };
      })(this);
      this.channel.consume(queueName, deserialize);
      debug('subscribed', queueName);
      return callback(null);
    };

    Client.prototype.ackMessage = function(message) {
      var fields;
      if (!this.channel) {
        return;
      }
      fields = message.amqp.fields;
      debug('ACK', fields.routingKey, fields.deliveryTag);
      return this.channel.ack(message.amqp, false);
    };

    Client.prototype.nackMessage = function(message) {
      var fields;
      if (!this.channel) {
        return;
      }
      fields = message.amqp.fields;
      debug('NACK', fields.routingKey, fields.deliveryTag);
      return this.channel.nack(message.amqp, false, false);
    };

    Client.prototype.registerParticipant = function(part, callback) {
      var data, msg;
      msg = {
        protocol: 'discovery',
        command: 'participant',
        payload: part
      };
      this.channel.assertQueue('fbp');
      data = new Buffer(JSON.stringify(msg));
      this.channel.sendToQueue('fbp', data);
      return callback(null);
    };

    return Client;

  })(interfaces.MessagingClient);

  dataSubscriptionQueueName = function(id) {
    if (!id) {
      throw new Error("Missing id");
    }
    return ".msgflo-broker-subscriptions-" + id;
  };

  bindingId = function(b) {
    return "[" + b.src + "]->[" + b.tgt + "]";
  };

  MessageBroker = (function(superClass) {
    extend(MessageBroker, superClass);

    function MessageBroker(address, options) {
      MessageBroker.__super__.constructor.call(this, address, options);
      if (!this.options.id) {
        this.options.id = uuid.v4();
      }
      this.subscriptions = {};
    }

    MessageBroker.prototype.connect = function(callback) {
      return MessageBroker.__super__.connect.call(this, (function(_this) {
        return function(err) {
          var name, options;
          if (err) {
            return callback(err);
          }
          name = dataSubscriptionQueueName(_this.options.id);
          options = {
            exclusive: true,
            durable: false,
            autoDelete: true
          };
          return _this.channel.assertQueue(name, options, function(err) {
            var onSubscribedQueueData, subscribeOptions;
            if (err) {
              return callback(err);
            }
            onSubscribedQueueData = function(message) {
              var data, error1, exchange, i, id, len, matches, results, sub;
              exchange = message.fields.exchange;
              debug('broker subscriber got message on exchange', exchange);
              matches = Object.keys(_this.subscriptions).filter(function(id) {
                var sub;
                sub = _this.subscriptions[id];
                return (sub != null ? sub.binding.src : void 0) === exchange;
              });
              results = [];
              for (i = 0, len = matches.length; i < len; i++) {
                id = matches[i];
                sub = _this.subscriptions[id];
                data = message.content;
                try {
                  data = JSON.parse(message.content.toString());
                } catch (error1) {
                  e = error1;
                  null;
                }
                results.push(sub.handler(sub.binding, data));
              }
              return results;
            };
            subscribeOptions = {
              noAck: true
            };
            return _this.channel.consume(name, onSubscribedQueueData, subscribeOptions, function(err) {
              debug('broker created subscription queue', err);
              return callback(err);
            });
          });
        };
      })(this));
    };

    MessageBroker.prototype.addBinding = function(binding, callback) {
      var bindDeadLetter, bindSrcTgt, pattern, steps;
      debug('Broker.addBinding', binding);
      if (binding.type === 'pubsub') {
        return this.channel.bindQueue(binding.tgt, binding.src, '', {}, callback);
      } else if (binding.type === 'roundrobin') {
        pattern = '';
        bindSrcTgt = (function(_this) {
          return function(callback) {
            var directExchange, directOptions;
            debug('binding src to tgt', binding.src, binding.tgt);
            directExchange = 'out-' + binding.src;
            directOptions = {};
            return _this.channel.assertExchange(directExchange, 'direct', directOptions, function(err) {
              if (err) {
                return callback(err);
              }
              return _this.channel.bindExchange(directExchange, binding.src, pattern, err, function() {
                if (err) {
                  return callback(err);
                }
                return _this.channel.bindQueue(binding.tgt, directExchange, pattern, {}, function(err) {
                  return callback(err);
                });
              });
            });
          };
        })(this);
        bindDeadLetter = (function(_this) {
          return function(callback) {
            var deadLetterExchange, deadLetterOptions;
            debug('binding deadletter queue', binding.deadletter, binding.tgt);
            deadLetterExchange = 'dead-' + binding.tgt;
            deadLetterOptions = {};
            return _this.channel.assertExchange(deadLetterExchange, 'fanout', deadLetterOptions, function(err) {
              if (err) {
                return callback(err);
              }
              return _this.channel.bindQueue(binding.deadletter, deadLetterExchange, pattern, {}, callback);
            });
          };
        })(this);
        steps = [];
        if (binding.src && binding.tgt) {
          steps.push(bindSrcTgt);
        }
        if (binding.deadletter && binding.tgt) {
          steps.push(bindDeadLetter);
        }
        return async.series(steps, callback);
      } else {
        return callback(new Error('Unsupported binding type: ' + binding.type));
      }
    };

    MessageBroker.prototype.removeBinding = function(binding, callback) {
      debug('Broker.removeBinding', binding);
      if (binding.type === 'pubsub') {
        return this.channel.unbindQueue(binding.tgt, binding.src, '', {}, callback);
      } else if (binding.type === 'roundrobin') {
        return callback(new Error("removeBinding() not supported for type='roundrobin'"));
      } else {
        return callback(new Error("Unsupported binding type: " + binding.type));
      }
    };

    MessageBroker.prototype.listBindings = function(from, callback) {
      return callback(null, []);
    };

    MessageBroker.prototype.subscribeData = function(binding, datahandler, callback) {
      var exchange, options, queue;
      exchange = binding.src;
      queue = dataSubscriptionQueueName(this.options.id);
      options = {
        autoDelete: true
      };
      return this.channel.bindQueue(queue, exchange, '', options, (function(_this) {
        return function(err) {
          var id;
          if (err) {
            return callback(err);
          }
          id = bindingId(binding);
          _this.subscriptions[id] = {
            binding: binding,
            handler: datahandler
          };
          return callback(null);
        };
      })(this));
    };

    MessageBroker.prototype.unsubscribeData = function(binding, datahandler, callback) {
      var id;
      id = bindingId(binding);
      delete this.subscriptions[id];
      return callback(null);
    };

    MessageBroker.prototype.listSubscriptions = function(callback) {
      var id, ref, sub, subs;
      subs = [];
      ref = this.subscriptions;
      for (id in ref) {
        sub = ref[id];
        subs.push(sub.binding);
      }
      return callback(null, subs);
    };

    MessageBroker.prototype.subscribeParticipantChange = function(handler) {
      var deserialize;
      deserialize = (function(_this) {
        return function(message) {
          var data, error1, out;
          debug('receive on fbp', message.fields.deliveryTag);
          data = null;
          try {
            data = JSON.parse(message.content.toString());
          } catch (error1) {
            e = error1;
            debug('JSON exception:', e);
          }
          out = {
            amqp: message,
            data: data
          };
          return handler(out);
        };
      })(this);
      this.channel.assertQueue('fbp');
      return this.channel.consume('fbp', deserialize);
    };

    return MessageBroker;

  })(Client);

  exports.Client = Client;

  exports.MessageBroker = MessageBroker;

}).call(this);
