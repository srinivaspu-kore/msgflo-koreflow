(function() {
  var Client, EventEmitter, MessageBroker, Queue, brokers, debug, interfaces, routing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = require('debug')('msgflo:direct');

  EventEmitter = require('events').EventEmitter;

  interfaces = require('./interfaces');

  routing = require('./routing');

  brokers = {};

  Client = (function(superClass) {
    extend(Client, superClass);

    function Client(address, options1) {
      this.address = address;
      this.options = options1;
      this.broker = null;
    }

    Client.prototype.connect = function(callback) {
      debug('client connect');
      this.broker = brokers[this.address];
      return callback(null);
    };

    Client.prototype.disconnect = function(callback) {
      debug('client disconnect');
      this.broker = null;
      return callback(null);
    };

    Client.prototype._assertBroker = function(callback) {
      var err;
      if (!this.broker) {
        err = new Error("no broker connected " + this.address);
      }
      if (err) {
        return callback(err);
      }
    };

    Client.prototype.createQueue = function(type, queueName, options, callback) {
      if (!callback) {
        callback = options;
        options = {};
      }
      this._assertBroker(callback);
      return this.broker.createQueue(type, queueName, callback);
    };

    Client.prototype.removeQueue = function(type, queueName, callback) {
      this._assertBroker(callback);
      return this.broker.removeQueue(type, queueName, callback);
    };

    Client.prototype.sendTo = function(type, queueName, message, callback) {
      debug('client sendTo', type, queueName);
      this._assertBroker(callback);
      return this.broker.sendTo(type, queueName, message, callback);
    };

    Client.prototype.subscribeToQueue = function(queueName, handler, callback) {
      this._assertBroker(callback);
      return this.broker.subscribeToQueue(queueName, handler, callback);
    };

    Client.prototype.ackMessage = function(message) {};

    Client.prototype.nackMessage = function(message) {};

    Client.prototype.registerParticipant = function(part, callback) {
      return this.createQueue('', 'fbp', (function(_this) {
        return function(err) {
          var msg;
          msg = {
            protocol: 'discovery',
            command: 'participant',
            payload: part
          };
          return _this.sendTo('outqueue', 'fbp', msg, callback);
        };
      })(this));
    };

    return Client;

  })(interfaces.MessagingClient);

  Queue = (function(superClass) {
    extend(Queue, superClass);

    function Queue() {}

    Queue.prototype.send = function(msg) {
      return this._emitSend(msg);
    };

    Queue.prototype._emitSend = function(msg) {
      return this.emit('message', msg);
    };

    return Queue;

  })(EventEmitter);

  MessageBroker = (function(superClass) {
    extend(MessageBroker, superClass);

    function MessageBroker(address) {
      this.address = address;
      routing.binderMixin(this);
      this.queues = {};
    }

    MessageBroker.prototype.connect = function(callback) {
      debug('broker connect');
      brokers[this.address] = this;
      return callback(null);
    };

    MessageBroker.prototype.disconnect = function(callback) {
      debug('broker disconnect');
      delete brokers[this.address];
      return callback(null);
    };

    MessageBroker.prototype.createQueue = function(type, queueName, callback) {
      if (this.queues[queueName] == null) {
        this.queues[queueName] = new Queue;
      }
      return callback(null);
    };

    MessageBroker.prototype.removeQueue = function(type, queueName, callback) {
      delete this.queues[queueName];
      return callback(null);
    };

    MessageBroker.prototype.sendTo = function(type, queueName, message, callback) {
      debug('broker sendTo', queueName);
      this.queues[queueName].send(message);
      return callback(null);
    };

    MessageBroker.prototype.subscribeToQueue = function(queueName, handler, callback) {
      if (this.queues[queueName] == null) {
        this.queues[queueName] = new Queue;
      }
      this.queues[queueName].on('message', function(data) {
        var out;
        out = {
          direct: null,
          data: data
        };
        return handler(out);
      });
      return callback(null);
    };

    MessageBroker.prototype.ackMessage = function(message) {};

    MessageBroker.prototype.nackMessage = function(message) {};

    MessageBroker.prototype.subscribeParticipantChange = function(handler) {
      return this.createQueue('', 'fbp', (function(_this) {
        return function(err) {
          return _this.subscribeToQueue('fbp', handler, function() {});
        };
      })(this));
    };

    return MessageBroker;

  })(interfaces.MessageBroker);

  exports.MessageBroker = MessageBroker;

  exports.Client = Client;

}).call(this);
