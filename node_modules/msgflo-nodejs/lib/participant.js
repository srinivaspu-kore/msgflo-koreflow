(function() {
  var EventEmitter, Participant, addQueues, async, common, debug, defaultDiscoveryPeriod, definitionToFbp, findPort, instantiateDefinition, newrelic, startParticipant, transport, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  common = require('./common');

  transport = require('./transport');

  newrelic = require('./newrelic');

  debug = require('debug')('msgflo:participant');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  uuid = require('uuid');

  findPort = function(def, type, portName) {
    var i, len, port, ports;
    ports = type === 'inport' ? def.inports : def.outports;
    for (i = 0, len = ports.length; i < len; i++) {
      port = ports[i];
      if (port.id === portName) {
        return port;
      }
    }
    return null;
  };

  definitionToFbp = function(d) {
    var def, portsWithQueue;
    def = common.clone(d);
    portsWithQueue = function(ports) {
      return ports.filter(function(p) {
        return p.queue != null;
      });
    };
    def.inports = portsWithQueue(def.inports);
    def.outports = portsWithQueue(def.outports);
    return def;
  };

  addQueues = function(ports, role) {
    var i, len, name, p;
    for (i = 0, len = ports.length; i < len; i++) {
      p = ports[i];
      if (p.hidden == null) {
        p.hidden = false;
      }
      name = role + '.' + p.id.toUpperCase();
      if (!p.queue && !p.hidden) {
        p.queue = name;
      }
    }
    return ports;
  };

  instantiateDefinition = function(d, role) {
    var def, id;
    def = common.clone(d);
    id = uuid.v4();
    def.role = role;
    if (!def.id) {
      def.id = def.role + "-" + id;
    }
    def.inports = addQueues(def.inports, def.role);
    def.outports = addQueues(def.outports, def.role);
    return def;
  };

  defaultDiscoveryPeriod = 60;

  if (process.env.MSGFLO_DISCOVERY_PERIOD) {
    defaultDiscoveryPeriod = parseInt(process.env.MSGFLO_DISCOVERY_PERIOD);
  }

  Participant = (function(superClass) {
    extend(Participant, superClass);

    function Participant(client, def, func, role, options) {
      this.func = func;
      if (options == null) {
        options = {};
      }
      this.onResult = bind(this.onResult, this);
      if (typeof client === 'string') {
        client = transport.getClient(client);
      }
      this.messaging = client;
      if (!role) {
        role = 'unknown';
      }
      this.definition = instantiateDefinition(def, role);
      this.running = false;
      this._transactions = new newrelic.Transactions(this.definition);
      this.options = options;
      if (!this.options.discoveryPeriod) {
        this.options.discoveryPeriod = defaultDiscoveryPeriod;
      }
    }

    Participant.prototype.start = function(callback) {
      return this.messaging.connect((function(_this) {
        return function(err) {
          debug('connected', err);
          if (err) {
            return callback(err);
          }
          return _this.setupPorts(function(err) {
            _this.running = true;
            if (err) {
              return callback(err);
            }
            return _this.register(function(err) {
              var period;
              if (err) {
                return callback(err);
              }
              period = _this.options.discoveryPeriod * 1000 / 2.2;
              setInterval(function() {
                return _this.register(function(err) {
                  if (err) {
                    return console.log('Could not send discovery message', err);
                  }
                });
              }, period);
              return callback(null);
            });
          });
        };
      })(this));
    };

    Participant.prototype.stop = function(callback) {
      this.running = false;
      return this.messaging.disconnect(callback);
    };

    Participant.prototype.send = function(inport, data, callback) {
      if (callback == null) {
        callback = function() {};
      }
      debug('got msg from send()', inport);
      return this.func(inport, data, (function(_this) {
        return function(outport, err, data) {
          if (err) {
            return callback(err);
          }
          return _this.onResult(outport, data, callback);
        };
      })(this));
    };

    Participant.prototype.emitData = function(outport, data) {
      return this.emit('data', outport, data);
    };

    Participant.prototype.onResult = function(outport, data, callback) {
      var port;
      port = findPort(this.definition, 'outport', outport);
      this.emitData(port.id, data);
      if (port.queue) {
        return this.messaging.sendTo('outqueue', port.queue, data, callback);
      } else {
        return callback(null);
      }
    };

    Participant.prototype.setupPorts = function(callback) {
      var setupInPort, setupOutPort;
      setupOutPort = (function(_this) {
        return function(def, callback) {
          var options;
          if (!def.queue) {
            return callback(null);
          }
          options = {};
          if (def.persistent != null) {
            options.persistent = def.persistent;
          }
          return _this.messaging.createQueue('outqueue', def.queue, options, callback);
        };
      })(this);
      setupInPort = (function(_this) {
        return function(def, callback) {
          var callFunc, options;
          if (!def.queue) {
            return callback(null);
          }
          callFunc = function(msg) {
            var msgid;
            debug('got msg from queue', def.queue);
            msgid = uuid.v4();
            _this._transactions.open(msgid, def.id);
            return _this.func(def.id, msg.data, function(outport, err, data) {
              _this._transactions.close(msgid, outport);
              if (err) {
                debug('process() error', err.message);
              }
              if (err && (data == null)) {
                return _this.messaging.nackMessage(msg);
              }
              return _this.onResult(outport, data, function(sendErr) {
                if (err || sendErr) {
                  return _this.messaging.nackMessage(msg);
                }
                if (msg) {
                  return _this.messaging.ackMessage(msg);
                }
              });
            });
          };
          options = {};
          if (def.persistent != null) {
            options.persistent = def.persistent;
          }
          return _this.messaging.createQueue('inqueue', def.queue, options, function(err) {
            if (err) {
              return callback(err);
            }
            _this.messaging.subscribeToQueue(def.queue, callFunc, callback);
            return debug('subscribe to', def.queue);
          });
        };
      })(this);
      return async.map(this.definition.outports, setupOutPort, (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return async.map(_this.definition.inports, setupInPort, function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null);
          });
        };
      })(this));
    };

    Participant.prototype.register = function(callback) {
      var definition;
      debug('register');
      definition = definitionToFbp(this.definition);
      return this.messaging.registerParticipant(definition, (function(_this) {
        return function(err) {
          debug('registered', err);
          return callback(err);
        };
      })(this));
    };

    return Participant;

  })(EventEmitter);

  startParticipant = function(library, client, componentName, id, callback) {
    var component, part;
    debug('starting', componentName, id);
    component = library[componentName];
    if (component == null) {
      return callback(new Error("No Participant factory in library for " + componentName));
    }
    part = component(client, id);
    return part.start(function(err) {
      return callback(err, part);
    });
  };

  exports.Participant = Participant;

  exports.startParticipant = startParticipant;

  exports.instantiateDefinition = instantiateDefinition;

}).call(this);
