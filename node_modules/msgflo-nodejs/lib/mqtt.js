(function() {
  var Client, MessageBroker, debug, e, error, interfaces, mqtt, routing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = require('debug')('msgflo:mqtt');

  interfaces = require('./interfaces');

  routing = require('./routing');

  try {
    mqtt = require('mqtt');
  } catch (error) {
    e = error;
    mqtt = e;
  }

  Client = (function(superClass) {
    extend(Client, superClass);

    function Client(address1, options1) {
      this.address = address1;
      this.options = options1;
      this.client = null;
      this.subscribers = {};
    }

    Client.prototype.connect = function(callback) {
      var onConnected;
      if (mqtt.message) {
        return callback(mqtt);
      }
      this.client = mqtt.connect(this.address);
      this.client.on('reconnect', (function(_this) {
        return function() {
          return debug('reconnect');
        };
      })(this));
      this.client.on('offline', (function(_this) {
        return function() {
          return debug('offline');
        };
      })(this));
      this.client.on('error', (function(_this) {
        return function(err) {
          debug('error', err);
          if (callback) {
            callback(err);
            callback = null;
          }
        };
      })(this));
      onConnected = (function(_this) {
        return function(connack) {
          debug('connected');
          _this.client.on('message', function(topic, message) {
            return _this._onMessage(topic, message);
          });
          if (callback) {
            callback(null);
            callback = null;
          }
        };
      })(this);
      return this.client.once('connect', onConnected);
    };

    Client.prototype.disconnect = function(callback) {
      this.client.removeAllListeners('message');
      this.client.removeAllListeners('connect');
      this.client.removeAllListeners('reconnect');
      this.client.removeAllListeners('offline');
      this.client.removeAllListeners('error');
      this.subscribers = {};
      return this.client.end((function(_this) {
        return function(err) {
          debug('disconnected');
          _this.client = null;
          return callback(err);
        };
      })(this));
    };

    Client.prototype.createQueue = function(type, queueName, options, callback) {
      if (!callback) {
        callback = options;
        options = {};
      }
      return callback(null);
    };

    Client.prototype.removeQueue = function(type, queueName, callback) {
      return callback(null);
    };

    Client.prototype.sendTo = function(type, queueName, message, callback) {
      var data, published;
      published = (function(_this) {
        return function(err, granted) {
          debug('published', queueName, err, granted);
          if (err) {
            return callback(err);
          }
          return callback(null);
        };
      })(this);
      data = JSON.stringify(message);
      debug('publishing', queueName, data);
      return this.client.publish(queueName, data, published);
    };

    Client.prototype.subscribeToQueue = function(queueName, handler, callback) {
      debug('subscribing', queueName);
      return this.client.subscribe(queueName, (function(_this) {
        return function(err) {
          var subs;
          debug('subscribed', queueName, err);
          if (err) {
            return callback(err);
          }
          subs = _this.subscribers[queueName];
          if (subs) {
            subs.push(handler);
          } else {
            _this.subscribers[queueName] = [handler];
          }
          return callback(null);
        };
      })(this));
    };

    Client.prototype.ackMessage = function(message) {};

    Client.prototype.nackMessage = function(message) {};

    Client.prototype._onMessage = function(topic, message) {
      var error1, handler, handlers, i, len, msg, out, results;
      if (!this.client) {
        return;
      }
      if (!Object.keys(this.subscribers).length > 0) {
        return;
      }
      msg = null;
      try {
        msg = JSON.parse(message.toString());
      } catch (error1) {
        e = error1;
        debug('failed to parse discovery message', e);
        msg = message.toString();
      }
      handlers = this.subscribers[topic];
      debug('message', handlers.length, msg !== null);
      if (!handlers) {
        return;
      }
      out = {
        data: msg,
        mqtt: message
      };
      results = [];
      for (i = 0, len = handlers.length; i < len; i++) {
        handler = handlers[i];
        results.push(handler(out));
      }
      return results;
    };

    Client.prototype.registerParticipant = function(part, callback) {
      var msg;
      msg = {
        protocol: 'discovery',
        command: 'participant',
        payload: part
      };
      return this.sendTo('inqueue', 'fbp', msg, callback);
    };

    return Client;

  })(interfaces.MessagingClient);

  MessageBroker = (function(superClass) {
    extend(MessageBroker, superClass);

    function MessageBroker(address, options) {
      MessageBroker.__super__.constructor.call(this, address, options);
      routing.binderMixin(this);
    }

    MessageBroker.prototype.subscribeParticipantChange = function(handler) {
      return this.createQueue('', 'fbp', (function(_this) {
        return function(err) {
          return _this.subscribeToQueue('fbp', handler, function() {});
        };
      })(this));
    };

    return MessageBroker;

  })(Client);

  exports.Client = Client;

  exports.MessageBroker = MessageBroker;

}).call(this);
